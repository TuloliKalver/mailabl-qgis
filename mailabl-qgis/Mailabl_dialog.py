# -*- coding: utf-8 -*-
# pylint: disable=missing-class-docstring
# pylint: disable=relative-beyond-top-level
# pylint: disable=no-nam
"""
/***************************************************************************
 MailablDialog
                                 A QGIS plugin
 Mailabl
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-07-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Kalver Tammik/Tuloli OÜ
        email                : tulolikt@gmail.com
 ***************************************************************************/

"""
import os
import gc
from PyQt5.QtCore import QTimer, Qt
from .config.SetupModules.SetupProjects import SetupProjects
from .config.SetupModules.SetupConrtacts import SetupConrtacts
from .config.SetupModules.SetupEasments import SetupEasments
from .config.SetupModules.SetupUsers import SetupUsers
from .utils.UIDeleteTables import UIDeleteTables
from .Functions.DeletProcessUIActions import DeletProcessUIActions
from .utils.UIDeleteCheckboxes import UIDeleteCheckboxes
from .utils.UIDeleteListViews import UIDeleteListViews
from .utils.UIDeleteButtonsManager import UIDeleteButtonsManager
from qgis.core import QgsProject
from qgis.PyQt import QtWidgets, uic
from PyQt5.QtWidgets import  QLineEdit, QListView, QAbstractItemView, QVBoxLayout
from PyQt5.QtGui import QStandardItemModel
from .app.web import loadWebpage, WebLinks
from .app.workspace_handler import WorkSpaceHandler, TabHandler
from .config.settings import SettingsDataSaveAndLoad, Version
from .config.SetupModules.SetupMainLayers import SetupCadastralLayers
from .config.settings import StoredLayers, Flags, settingPageElements
from .config.QGISSettingPaths import LayerSettings, SettingsLoader
from .config.ui_directories import PathLoaderSimple
from .config.mainwidget import WidgetInfo
from .KeelelisedMuutujad.modules import Module
from .app.checkable_comboboxes import ComboBoxFunctions, ComboBoxMapTools
from .app.remove_processes import RemoveProcess
from .app.ui_controllers import FrameHandler, WidgetAnimator, secondLevelButtonsHandler, stackedWidgetsSpaces, alter_containers
from .app.View_tools import listView_functions, shp_tools, tableView_functions
from .Functions.item_selector_tools import CadasterSelector, properties_selectors
from .Functions.SearchEngines import searchGeneral,ModularSearchEngine
from .Functions.delete_items import DeletingProcesses, MapRestictionsAndListWidgetDataInserion
from .Functions.Tools import tableFunctions
#from .Functions.AddProperties.AddProperties_dev import AddProperties_dev
from .Functions.RemoveProperties.RemoveSelectedProperties import DeleteActions
from .processes.ImportProcesses.Import_shp_file import SHPLayerLoader
from .processes.OnFirstLoad.FirstLoad import Startup
from .processes.SyncProperties.syncMailablProperties import PropertiesBaseMap
from .queries.python.access_credentials import  (clear_UC_data,
                                                get_access_token, print_result,
                                                save_user_name)
from .queries.python.users.user_info import UserSettings
from .queries.python.projects.ProjectTableGenerators.projects import Projects
from .queries.python.property_data import Properties, MyLablChecker
from .utils.ComboboxHelper import GetValuesFromComboBox
from .KeelelisedMuutujad.messages import Headings, HoiatusTexts,HoiatusTextsAuto, EdukuseTexts
from .Functions.Easements.EasementsToolsHandler import EasementTools
from .Functions.Folders.folders import copy_and_rename_folder
from .Functions.EVEL.evel_general import EVELTools
from .Functions.HomeTree.BuildTree import MyTreeHome
from .Functions.HomeTree.TreePropertiesSearches import FeatureInfoTool, FeatureInfoToolSearch
from .Functions.Searchpropertyfromlayer import SearchProperties
#from .Functions.AddProperties.AddProcessPrepareTables import AddProcessPrepareTables
from .widgets.connector_widget_engine.UI_controllers import PropertiesConnector
from .processes.OnFirstLoad.CloseUnload import Unload
from .utils.ToggleSwitch import ToggleSwitch, StoreValues_Toggle
from .KeelelisedMuutujad.Maa_amet_fields import Katastriyksus
from .utils.UIWindowHelpers import WindowPositionHelper, WindowManagerMinMax
from .utils.custom_event_filter import BlockButtonsToPreferLabelEventFilter, ReturnPressedManager
from .utils.TableUtilys.TableHelpers import TableDataInserter

from .utils.TableUtilys.TableHelpers import TableHelper
from .utils.signal_utils import execute_with_block
from .app.button_connector import SettingsModuleButtonConnector, PropertiesModuleButtonConnector
from .utils.SpatialDataHelper import ZoomForModuleData
from .utils.messagesHelper import ModernMessageDialog



###########################################################################################
            ### MODULES IMPRORT FOR NEW UPDAATE

##########################################################################################
from functools import partial
from .utils.ButtonsHelper import ButtonHelper
from .utils.CheckBoxHelper import CheckboxHelper
from .Common.app_state import PropertiesProcessStage, Processes
from .utils.SelectionActions import SelectionActions
from .utils.UIStateManager import UIStateManager
from .utils.WidgetHelpers import WidgetAndWievHelpers, ListSelectionHandler
from .utils.MapHelpers import MapDataFlowHelper
from .utils.MapToolsHelper import MapToolsHelper
from .Functions.FlowPropertiesAdd import AddProperties
from .Common.ChaceHelpers import CacheUpdater
from .utils.ListHelper import  ListSelections


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Mailabl_dialog_base.ui'))

###############################################################################################################
# Set plugin_dir as a class variable
plugin_dir = os.path.dirname(__file__)

################################################################################################################

#initialize

pealkiri = Headings()
sisu = HoiatusTexts()
edu = EdukuseTexts()

comboboxes = ComboBoxFunctions()
process = RemoveProcess()

list_functions = listView_functions()
table_functions = tableView_functions()
graph_tools = ComboBoxMapTools()
properties_functions = Properties()

setting_layer = StoredLayers
selector_class = properties_selectors()
projects = CadasterSelector()


load = SettingsDataSaveAndLoad()
stacked_widgets = stackedWidgetsSpaces()
checker = MyLablChecker()
table_data = tableFunctions
f_delete = DeletingProcesses()


#set parameters

input_layer_name = load.load_SHP_inputLayer_name()
county_nimi_field = Katastriyksus.mk_nimi #'MK_NIMI'
state_nimi_field = Katastriyksus.ov_nimi #'OV_NIMI'
city_nimi_field = Katastriyksus.ay_nimi #"AY_NIMI"


################################################################################################################

class MailablDialog(QtWidgets.QDialog, FORM_CLASS):
    
################################################################################################################

    def __init__(self, parent=None):
        """Constructor."""
        super(MailablDialog, self).__init__(parent)
        
        # Rest of your __init__ method...
        # Call the function to create the necessary layer structure
        
    #Creat instances

        self.setupUi(self)
       # Set always on top flag


#################################################################################################################

            #NEW INITIALIZERS

#################################################################################################################

        # Set this dialog as the main dialog for ButtonHelper
        ButtonHelper.set_dialog(self)
        ListSelectionHandler.set_dialog(self)
        TableHelper.set_dialog(self)
        MapDataFlowHelper.set_dialog(self)
        WidgetAndWievHelpers.set_dialog(self)
        CheckboxHelper.set_dialog(self)
        
        SelectionActions.initialize(self,
            label=self.lblActionName, 
            button_frame=self.frPropertiFlowHolder,
            table_view=self.tvSelectedMapItems,
            confirm_button=self.pbConfirmAction,
            )

        UI = UIStateManager(self)

##########################################################################################################

                ###UNTILL HERE UNORGANIZED NEW PARTS

##########################################################################################################


        Startup.FirstLoad(self)
        Startup.on_load(self)

        #setup login dialog and hide frames to block functionality!
        startup_frames = [self.leftMenuContainer,
                        self.rightMenuContainer, 
                        self.frAgreements,
                        self.swWorkSpace,
                        self.lblUserAccessDenied
                        ]


        TableHelper.set_dialog(self)
        
        self.window_manager = WindowPositionHelper(self)

        #self.AddProcessPrepareTables = AddProcessPrepareTables(self)

        # Initialize ReturnPressedManager
        self.return_pressed_manager = ReturnPressedManager(self)
                
        # Setup connections for existing QLineEdit widgets
        label_callbacks = {
            'isSelectedCadaster': self.start_propertie_search,
            'le_searchContracts': lambda: self.universalSearchWrapper(Module.CONTRACT),
            'le_searchProjects': lambda: self.universalSearchWrapper(Module.PROJECT),
            'leSearcheasements': lambda: self.universalSearchWrapper(Module.EASEMENT),
            'leText_For_Sync_GreateLayerName': self.generate_virtual_mapLayer_synced_with_Mailabl
        }

        label_callbacks_user = {
            'lePassword': lambda: self.save_user_data(startup_frames),
            'leUsername': self.activate_line_edit,
        }
        self.return_pressed_manager.setup_connections(label_callbacks, label_callbacks_user)

        # Initialize custom event filter and set button focus policy
        self.custom_event_filter = BlockButtonsToPreferLabelEventFilter(self)
        self.custom_event_filter.set_button_focus_policy()

        self.setup_timer()
    
        # Install event filter on the main window
        self.installEventFilter(self.custom_event_filter)
        
#####################################################################################################################

                            #NEW BUTTON CONNECTIONS
 
#####################################################################################################################        

        self.setup_button_actions()

        #UIStateManager.disable_all()

        self.lvCounty.itemSelectionChanged.connect(self.get_connected_signal)
        self.lvState.itemSelectionChanged.connect(self.get_connected_signal)
        self.lvSettlement.itemSelectionChanged.connect(self.get_connected_signal)

        self.chkSelectAllSettlements.stateChanged.connect(self.on_toggle_all_with_list)
        self.chkToggleRoadSelection.stateChanged.connect(self.on_toggle_select_only_non_transport_properties)
#####################################################################################################################

                        #OLD BUTTON CONNECTIONS

######################################################################################################################

        self.sw_HM.setCurrentIndex(0)
        initial_size = self.UC_Main_Frame.size()
        self.resize(initial_size.width()+5, initial_size.height()+5)

        # Hide typing password
        self.lePassword.setEchoMode(QLineEdit.Password)
        
        
        # declaring Delete process elements    
        pbDel_State = self.pbDel_State
        pbDel_city =  self.pbDel_City
        pbDel_PreConfirm = self.pbDel_PreConfirm

        #TODO - this is not working yet!!!#
        self.treeView.setVisible(False)

        self.f_delete_lists = UIDeleteButtonsManager(pbDel_State, pbDel_city, pbDel_PreConfirm)

        lwDel_State_Names = self.lwDel_State_Names
        lwDelete_Cities_Names = self.lwDelete_Cities_Names
        lwDelete_County_Names = self.lwDelete_County_Names
        self.f_delete_views = UIDeleteListViews(lwDel_State_Names, lwDelete_Cities_Names, lwDelete_County_Names)

        cbDel_ChooseAll_Data_properties = self.cbDel_ChooseAll_Data_properties
        cbDel_ChooseAll_Data_include_Allroads = self.cbDel_ChooseAll_Data_include_Allroads
        cbDel_ChooseAll_Data_transport = self.cbDel_ChooseAll_Data_transport
        cbDel_ChooseAll_States = self.cbDel_ChooseAll_States
        cbDel_ChooseAll_Cities = self.cbDel_ChooseAll_Cities
        self.f_delete_checkboxes = UIDeleteCheckboxes(cbDel_ChooseAll_Data_properties, cbDel_ChooseAll_Data_include_Allroads, 
                                                    cbDel_ChooseAll_Data_transport, cbDel_ChooseAll_States, cbDel_ChooseAll_Cities)
        
        tbl_Delete_streets = self.tbl_Delete_streets
        tbl_Delete_properties = self.tbl_Delete_properties
        self.f_delete_tables = UIDeleteTables(tbl_Delete_streets, tbl_Delete_properties)
        
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        lblLable_14= self.label_14
        lblLayerProjects_Properties = self.lblLayerProjects_Properties


        settingPageElements(lblcurrent_main_layer_label, lblnewCadastrals_input_layer_label, lblSHPNewItems, lblLable_14, lblLayerProjects_Properties)
        
    
        self.set_layer_settings_labels()
        

        
        object_listView_Add_State = self.listWidget_State
        object_listView_Add_State.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        
        object_listView_Add_City = self.listWidget_City
        object_listView_Add_City.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys

        object_tableView_Add_Properties_list = self.tblvResults_Confirm
        object_tableView_Add_Street_list = self.tblvResults_streets_Confirm


    #Confirm password entering
        self.pbLogin.clicked.connect(lambda: self.save_user_data(startup_frames))
        self.pbCancelLogin.clicked.connect(self.remove_UC_data)

        self.pbLogOut.clicked.connect(self.log_out)
        self.pbLogOut.setVisible(False)

# Opens and handles the sub menu
        
        self.pbeasements.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Easements(self))
        self.pbRefreshEasementTable.clicked.connect(lambda: WorkSpaceHandler.easements_reload(self))
        self.pbContracts.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Contracts(self))
        self.pbRefresh_tblMailabl_contracts.clicked.connect(lambda: WorkSpaceHandler.contracts_reload(self))
        self.pbMapThemes.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_MapThemes_FrontPage(self))
        self.pbMapThemes.setEnabled(False)
        self.pbAddDrawings.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_AddDrawings_FrontPage(self))
        self.pbAddDrawings.setEnabled(False)
    
        self.pbSyncMailabl.clicked.connect(lambda: WorkSpaceHandler.Open_generate_mapLayer_synced_with_Mailabl_first_page(self))
    
        self.pbSync_start_sync.clicked.connect(self.generate_virtual_mapLayer_synced_with_Mailabl)
        
        self.pbRefresh.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Refresh(self))
        self.pbExpand.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Expand(self))
        self.pbRemove.clicked.connect(lambda: WorkSpaceHandler.swDeleteworkspace(self))


    # Setting processes 

        self.pbSettings.clicked.connect(self.toggle_settings_main_view)
        #Add shae files

        
    # workspace page ID 5 = Homepage
        self.pbHome.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Properties(self))

        # workspace page ID 7 = Projects
        self.pbProjects.clicked.connect(lambda: WorkSpaceHandler.swWorkspace_Projects(self))
        self.pbRefresh_tblMailabl_projects.clicked.connect(self.update_tblMailabl_projects)
        
        self.pbGenProjectFolder.clicked.connect(self.generate_project_folder)

        self.evel_tools = EVELTools()

        PropertiesModuleButtonConnector().button_controller(self)
        SettingsModuleButtonConnector.button_controller(self)
        self.pbGreateEVEL.setEnabled(False)

        # Logo ja kodukas
        self.pbMailabl.clicked.connect(lambda: loadWebpage.open_webpage(WebLinks().page_mailabl_home))
        self.btnUserPolicy.clicked.connect(lambda: loadWebpage.open_webpage(WebLinks().page_mailabl_terms_of_use))
        self.btnPrivacyPolicy.clicked.connect(lambda: loadWebpage.open_webpage(WebLinks().page_privacy_policy))
        # Avab maa-ameti repositooriumi kaardiandmete alla laadimiseks
        

        #self.pbRefresh.clicked.connect(self.check_for_updates)
        
        #Setting workspace buttons and functions
        self.pbLayerSettings.clicked.connect(self.layer_setup)
        self.pbSettings_Setup_Projects.clicked.connect(lambda: SetupProjects.load_project_settings_widget(self))
        self.pbSettings_Setup_Contracts.clicked.connect(lambda: SetupConrtacts.load_contract_settings_widget(self))
        self.pbSettingsSetupEasements.clicked.connect(lambda: SetupEasments.load_easements_settings_widget(self))
        self.pbUserSettings.clicked.connect(lambda: SetupUsers.load_user_settings_widget(self))

        self.lblPhotos.setEnabled(False)
        self.lblPhtosText.setEnabled(False)
        
        
###########################################
    #process buttons in develepment 
    
        #self.listWidget_county.itemClicked.connect(self.get_state_list)
        self.pbDone_County.clicked.connect(self.get_state_list)
        self.pbDone_State.clicked.connect(self.get_city_list)
        #self.pbDoneCity.clicked.connect(self.AddProcessPrepareTables.prepare_properties_list_and_Add_to_table_updated_with_selecting_items)


        self.pbDel_County.clicked.connect(self.delete_process_after_county)
        pbDel_State.clicked.connect(self.delete_process_after_state)
        pbDel_city.clicked.connect(self.delete_process_after_city)

        pbDel_PreConfirm.clicked.connect(self.DeleteProcess_check_validity_in_Mylabl)
        
        lwDelete_County_Names.clicked.connect(self.Delete_reset_stage)
        lwDel_State_Names.clicked.connect(self.Delete_reset_to_stage_state)
        
        #self.pbDelete_items_getCounty.clicked.connect(self.get_Mailabl_existing_counties)
        

        self.pbSearchProjects.clicked.connect(lambda: self.universalSearchWrapper(Module.PROJECT))
        self.pbSearchContracts.clicked.connect(lambda: self.universalSearchWrapper(Module.CONTRACT))
        self.pbSearcheasements.clicked.connect(lambda: self.universalSearchWrapper(Module.EASEMENT))
        
    #Adding and removing        
        self.pbSearch_Add.clicked.connect(lambda: searchGeneral.search_cadastral_items_by_values(self))
        
    #update selections in adding proccess
        self.cbChooseAll_States.stateChanged.connect(lambda state, view_state=object_listView_Add_State: list_functions.toggleListSelection(view_state, state))
        self.cbChooseAll_Cities.stateChanged.connect(lambda state, view_state=object_listView_Add_City: list_functions.toggleListSelection(view_state, state))
        self.cbChooseAllAdd_properties.stateChanged.connect(lambda state, view_state=object_tableView_Add_Properties_list: list_functions.toggleListSelection(view_state, state))
        self.cbChooseAllAdd__street_properties.stateChanged.connect(lambda state, view_state=object_tableView_Add_Street_list: list_functions.toggleListSelection(view_state, state))
        self.cbOnPropertiesTab_Include_streets.stateChanged.connect(lambda state, view_state=object_tableView_Add_Street_list: list_functions.toggleListSelection(view_state, state))


        self.tblvResults_streets_Confirm.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tblvResults_Confirm.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tblvResults_Confirm.setSelectionMode(QAbstractItemView.MultiSelection)
        # Set an empty model initially if necessary
        self.tblvResults_Confirm.setModel(QStandardItemModel(self.tblvResults_Confirm))
        



#TODO - Delete - remove line of code
    #update selections in deleting proccess
        self.cbDel_ChooseAll_States.stateChanged.connect(lambda state, view_name=lwDel_State_Names: list_functions.toggleListSelection(view_name, state))
        self.cbDel_ChooseAll_Cities.stateChanged.connect(lambda city, view_name=lwDelete_Cities_Names: list_functions.toggleListSelection(view_name, city))
        self.cbDel_ChooseAll_Data_properties.stateChanged.connect(lambda state, view_state=tbl_Delete_properties: list_functions.toggleListSelection(view_state, state))
        self.cbDel_ChooseAll_Data_transport.stateChanged.connect(lambda state, view_state=tbl_Delete_streets: list_functions.toggleListSelection(view_state, state))
        self.cbDel_ChooseAll_Data_include_Allroads.stateChanged.connect(lambda state, view_state=tbl_Delete_streets: list_functions.toggleListSelection(view_state, state))
        
        tbl_Delete_properties.setSelectionBehavior(QAbstractItemView.SelectRows)
        tbl_Delete_streets.setSelectionBehavior(QAbstractItemView.SelectRows)



        
        #self.pbCooseFromMap_Add.clicked.connect(self.manualy_choose_properties_to_Add)
        
        self.listWidget_county.clicked.connect(self.update_map_with_restricted_county)
        self.listWidget_State.clicked.connect(self.update_step_2)
        self.listWidget_City.clicked.connect(self.update_step_3)
        
        
        self.pbConfirm_action.clicked.connect(self.StartImportProcess)

        self.pbMainMenu.clicked.connect(self.handleSidebar_leftButtons)
        

        
        self.zoom_handler = ZoomForModuleData()
        self.pbZoomProjects.clicked.connect(
            lambda: self.zoom_handler.zoom_functions[Module.PROJECT](self, module=Module.PROJECT, language="et")
        )
        
        self.helpMenuToggle.clicked.connect(self.handleSidebar_help)
        self.helpMenuToggle.setVisible(False) #nupp on peidus kuni funktiooni välja arendamiseni 

        pbEasementTools = self.pbEasementsTools
        pbEasementTools.clicked.connect(lambda: self.load_easement_widget(pbEasementTools))

        self.leSearch_Add.setEnabled(False)
        self.pbSearch_Add.setEnabled(False)
        self.pbCooseFromMap_Add.setEnabled(False)
        self.lblDel_Aditiona_txt.setEnabled(False)
        self.pbCompiler.clicked.connect(self.start_compielre)


        # Connect the button signal to the method
        self.pbSelecPrpertiesOveral.clicked.connect(self.start_feature_info_tool)
        self.pbDisconnect.clicked.connect(self.stop_feature_info_tool)
        self.pbDisconnect.setEnabled(False)
        self.pbOpenProperty.clicked.connect(self.open_properties_item_in_mylabl)

        self.pbCadastralSearch.clicked.connect(self.start_propertie_search)

        self.main_window_toggle_option()
        self.pbOpenProperty.setEnabled(False)







    def on_label_return_pressed(self):
        # Identify which label sent the signal
        sender = self.sender()
        if isinstance(sender, QLineEdit):
            self.start_propertie_search()


    def start_propertie_search(self):
        gc.collect()  # Force garbage collection
        engine = SearchProperties(self)
        label = self.isSelectedCadaster
        result = engine.search_for_item(label=label)
        if result is None:
            return
        else:
            address = self.lblAddress_value
            purpose = self.lblPurpose_value
            area = self.lblArea_value
            created_at = self.CreatedAt_value
            updated_at = self.UpdatedAt_value
            treeWidget = self.treeWidget
            lblRegistryNr = self.RegistryNr_value
            lblCadastralNr = self.CadasterNr_value
            open_cadastral_button = self.pbOpenProperty
            tool_feature = FeatureInfoToolSearch(
                window=self,
                lblCadastralNr=lblCadastralNr,
                lblRegistry= lblRegistryNr,
                address=address,
                purpose=purpose,
                area=area,
                created_at=created_at,
                updated_at=updated_at,
                treeWidget=treeWidget,
                property_button=open_cadastral_button
            )

            tool_feature.for_search_results()


    def main_window_toggle_option(self):
        label_for_toggle = self.ToggleStatus
        self.togglebutton = ToggleSwitch(label_for_toggle)
        self.toggle_value = StoreValues_Toggle().get_toggle_status()
        print(f"toggle_value before clicked: {self.toggle_value}")

        self.frame1 = self.fToggleHolder
        self.frame2 = self.freopenToggle
        self.layout1 = QVBoxLayout(self.frame1)
        self.layout2 = QVBoxLayout(self.frame2)

        # Initially add the toggle button to frame1's layout
        self.layout1.addWidget(self.togglebutton)
        toggle_value_on_load = StoreValues_Toggle().get_toggle_status()
        print(f"toggle_value before clicked: {toggle_value_on_load}")
        self.handle_toggle(toggle_value_on_load)
        # Connect the toggled signal
        self.togglebutton.toggled.connect(self.handle_toggle)
        gc.collect()  # Force garbage collection
            

    def handle_toggle(self, state):
        if state:
            #print("started False toggle setup")
            self.ToggleStatus.setText("Järgmisel laadimisel ära enam seda juhendit näita")
            self.layout2.removeWidget(self.togglebutton)
            self.togglebutton.setParent(self.frame1)
            self.layout1.addWidget(self.togglebutton)
            self.set_start_page_based_on_toggle_and_preferred_settings()
            #print("started 'swWorkspace_home'")
            gc.collect()  # Force garbage collection
            
        else:
            #print("started True toggle setup")
            self.ToggleStatus.setText("Näita kirjeldust")
            self.layout1.removeWidget(self.togglebutton)
            self.togglebutton.setParent(self.frame2)
            self.layout2.addWidget(self.togglebutton)
            WorkSpaceHandler.swWorkSpace_Properties(self)
            gc.collect()  # Force garbage collection
            
            #print("started 'swWorkspace_Proerties'")
        #print(f"Toggle switch is {'ON' if state else 'OFF'}")



    def open_properties_item_in_mylabl(self):
        MyTreeHome.open_property()
    
    def load_propertieID_from_memory (self):
        value = self.propertyID_location
        return value

    def setup_timer(self):
        self.timer = QTimer()
        self.timer.setInterval(10000)  # 10 seconds timeout
        self.timer.timeout.connect(self.stop_feature_info_tool_timed)

    def start_feature_info_tool(self):        
        self.pbSelecPrpertiesOveral.setEnabled(False)
        label = self.isSelectedCadaster
        address = self.lblAddress_value 
        purpose = self.lblPurpose_value 
        area = self.lblArea_value  
        created_at = self.CreatedAt_value  
        updated_at = self.UpdatedAt_value  
        treeWidget = self.treeWidget
        lblRegistryNr = self.RegistryNr_value
        lblCadastralNr = self.CadasterNr_value
        pbOProperty = self.pbOpenProperty
        treeView = self.treeView
        global feature_tool  # Use global variable to keep reference
        
        self.window_manager_minmax = WindowManagerMinMax(self)
        self.window_manager_minmax._minimize_window()
        feature_tool = FeatureInfoTool(
            label=label,
            lblCadastralNr=lblCadastralNr,
            lblRegistry= lblRegistryNr,
            address=address,
            purpose=purpose,
            area=area,
            created_at=created_at,
            updated_at=updated_at,
            treeWidget=treeWidget,
            reset_timer=lambda: self.reset_timer(),
            main_window = self,
            pbOProperty= pbOProperty,
            treeView=treeView
        )
        self.pbDisconnect.setEnabled(True)
        self.timer.start()

    def stop_feature_info_tool(self):
        global feature_tool  # Use global variable to keep reference
        if feature_tool:
            feature_tool.disconnect_signal()
            print("disconnecting with button")
            self.pbDisconnect.setEnabled(False)
            self.pbSelecPrpertiesOveral.setEnabled(True)
        self.timer.stop()
        gc.collect()  # Force garbage collection
            

    def stop_feature_info_tool_timed(self):
        global feature_tool  # Use global variable to keep reference
        if feature_tool:
            feature_tool.disconnect_signal_timed()
            print("disconnecting with timer")
            self.pbDisconnect.setEnabled(False)
            self.pbSelecPrpertiesOveral.setEnabled(True)
        self.timer.stop()
        gc.collect()  # Force garbage collection
            

    def reset_timer(self):
        self.timer.start()


    def start_compielre(self):
        from .processes.SyncProperties.CompyleOldPropertyModel import LayerCompilerSetup
        print("button clicked")
        LayerCompilerSetup.load_layer_compiler_widget(self)
        gc.collect()  # Force garbage collection
            
    def log_out(self):
        Unload.log_out(self)

    def load_easement_widget(self, button):
        button.setEnabled(False)
        # Create an instance of EasementTools and pass tweasementView
        self.easement_tools = EasementTools(self.tweasementView)
        # Connect the widgetClosed signal to a method in your main class
        table = self.tweasementView
        selection_model = table.selectionModel()
        if selection_model.hasSelection():
            self.showMinimized()
            self.easement_tools.widgetClosed.connect(lambda: self.on_easement_widget_closed(button))
            # Call the load_widget method of the EasementTools instance
            self.easement_tools.load_widget()
        else:
            text = HoiatusTexts().andmed_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)
            self.showNormal()
            button.setEnabled(True)
            return
    
    def on_easement_widget_closed(self, button):
        button.setEnabled(True)
        self.showNormal()

    def load_properties_connector(self, module, table, button):
        button_contracts = self.pbContracts_Connect_properties
        button_projects = self.pbProjects_Connect_properties
        button_easements = self.pbEasementsConnectProperties
        button_easements.setEnabled(False)
        buttons = [button_contracts, button_easements, button_projects]
        for single_button in buttons:
            single_button.setEnabled(False)

        #button.setEnabled(False)
        selection_model = table.selectionModel()
        if selection_model.hasSelection():
            self.showMinimized()
            # Create an instance of PropertiesConnector with the table instance
            self.properties_connector = PropertiesConnector(table)
            # Connect the widgetClosed signal to a method in your main class
            self.properties_connector.ConnectorWidgetClosed.connect(lambda: self.on_properties_connector_widget_closed(button))
            # Load the properties connector widget UI
            self.properties_connector.load_propertiesconnector_widget_ui(module)
            gc.collect()  # Force garbage collection
            
        else:
            text = HoiatusTexts().andmed_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)
            for single_button in buttons:
                single_button.setEnabled(True)
            button.setEnabled(True)
            gc.collect()  # Force garbage collection
            return

    def on_properties_connector_widget_closed(self, button):
        button_contracts = self.pbContracts_Connect_properties
        button_projects = self.pbProjects_Connect_properties
        button_easements = self.pbEasementsConnectProperties
        buttons = [button_contracts, button_easements, button_projects]
        for single_button in buttons:
            single_button.setEnabled(True)
        button.setEnabled(True)
        #print("Closed properties loader window")
        self.showNormal()
        gc.collect()  # Force garbage collection
            
    def generate_project_folder(self):
        self.pbGenProjectFolder.blockSignals(True)
        table = self.tblMailabl_projects
        selection_model = table.selectionModel()

        if selection_model.hasSelection():
            copy_and_rename_folder(table)
        
        else:
            text = HoiatusTexts().projekt_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)
        
        self.pbGenProjectFolder.blockSignals(False)
        gc.collect()  # Force garbage collection
            
########################################################################
    def universalSearchWrapper(self, module_name):
        search_engine = ModularSearchEngine()
        search_engine.universalSearch(self,module_name)


    def handleSidebar_help(self):
        button1 = self.pbMailabl        
        help_menu = self.helpMenu
        container = self.rightMenuContainer
        container_width = container.width()
        
        buttons = [button1]

        original_texts = {button1: " Mailabl.com"                
                        }
        new_texts = {button1: ""
                        }
        #measure text lenght
        length = len(button1.text())
        alter_containers.toggle_right_menu(self, length, buttons, original_texts, new_texts, help_menu, container, container_width)
        gc.collect()  # Force garbage collection
            

    def handleSidebar_leftButtons(self):
        button1 = self.pbSettings
        button2 = self.pbExpand
        button3 = self.pbRefresh
        button4 = self.pbRemove

        #button6 is free to set any new buttons       
        
        
        button10 = self.pbAddDrawings
        button11 = self.pbContracts
        button12 = self.pbMainContract
        button13 = self.pbPreContacts
        button14 = self.pbHome
        button15 = self.pbMapThemes
        button16 = self.pbProjects
        button17 = self.pbeasements
        button18 = self.pbSyncMailabl

        left_menu = self.leftMenuContainer
        container = self.leftMenuContainer
        container_width = container.width()
        #print(container_width)
        
        buttons = [button1, 
                button2,
                button3,
                button4,
                #button6 is free to set any new buttons
                button5,
                button7,
                button8,
                button9,
                button10,
                button11,
                button12,
                button13,
                button14,
                button15,
                button16,
                button17,
                button18]

        original_texts = {button1: "Sätted",
                            button2: "Kinnistute lisamine",
                            button3: "Andmete värskendamine",
                            button4: "Kinnistute eemaldamine",
                            button5: "Toimingud kinnistutega",
                            #button6 is free to set any new buttons
                            button7: "Andmete laadimine",
                            button8: "Maa-ametisse",
                            button9: "Lae algandmed",
                            button10: "Teostusjoonised",
                            button11: "Lepingud",
                            button12: "Teenuslepingud",
                            button13: "Liitumislepingud",
                            button14: "Kinnistud",
                            button15: "Teemakaardid",
                            button16: "Projektid",
                            button17: "Servituudid",
                            button18: "Mailabliga sünkroniseerimine"
                        }

        new_texts = {button1: "",
                    button2: "",
                    button3: "",
                    button4: "",
                    button5: "",
                    #button6 is free to set any new buttons
                    button7: "",
                    button8: "",
                    button9: "",
                    button10: "",
                    button11: "",
                    button12: "",
                    button13: "",
                    button14: "",
                    button15: "",
                    button16: "",
                    button17: "",
                    button18: ""
                        }
        #Chose a random button to measure text lenght
        length = len(button18.text())
        alter_containers.toggle_left_menu(self, length, buttons, original_texts, new_texts, left_menu, container, container_width)

    def StartImportProcess(self):
        AddProperties_dev.check_for_duplicates_and_add_only_matches(self)

    def update_step_2 (self):
        layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()

        hide_buttons = [ 
                self.pbDoneCity,
                self.pbConfirm_action,
                self.pbCancel_streets_reset,
                self.pbConfirm_streets_action]
        
        list_views = [
                        self.listWidget_City]
        
        checkboxes = [
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]


        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)

    def update_step_3 (self):
        layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()

        hide_buttons = [ 
                self.pbConfirm_action,
                self.pbCancel_streets_reset,
                self.pbConfirm_streets_action]
        
        list_views = []
        
        checkboxes = [
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]


        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)
    
    def update_map_with_restricted_county (self):
        input_layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]

        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()

        hide_buttons = [self.pbDone_State, 
                self.pbDoneCity,
                self.pbConfirm_action,
                self.pbCancel_streets_reset,
                self.pbConfirm_streets_action]
        
        list_views = [self.listWidget_State, 
                        self.listWidget_City]
        
        checkboxes = [self.cbChooseAll_States,
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]

        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)

        viewItem_county = self.listWidget_county

        layer.blockSignals(False)
        shp_tools.county_map_simplifier(county_nimi_field, input_layer_name, viewItem_county)
        
    #Functions in Development
        
    def get_state_list(self):
        self.sw_HM.setCurrentIndex(3)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
        self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(2)
        try:
            layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        except IndexError:
            #print(f"Layer '{input_layer_name}' not found.")
            text = HoiatusTextsAuto.input_layer_missing(input_layer_name)
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)
            
            return
        hide_buttons = [self.pbDone_State, 
                        self.pbDoneCity,
                        self.pbConfirm_action,

                        self.pbCancel_streets_reset,
                        self.pbConfirm_streets_action]
        
        list_views = [self.listWidget_State, 
                        self.listWidget_City]
        
        checkboxes = [self.cbChooseAll_States,
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]


        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)
        

        viewItem_county = self.listWidget_county
        viewItem_state = self.listWidget_State
        
        # When calling functions in other classes, pass object names as strings
        
        item_county = viewItem_county.currentItem()
        item_state = viewItem_state.selectedItems()
        
        county_restriction = item_county.text() if item_county is not None else ""
        state_restrictions = "', '".join([item.text() for item in item_state]) if item_state else ""
        #print(f"Selected items state: {state_restrictions}")
        city_restrictions_before = ""
        
        #print(f"Restriction: {restriction}")
        item_count_before = shp_tools.count_items_in_layer(input_layer_name)
        sorted_values = shp_tools.create_item_list_with_where(viewItem_state, item_count_before, county_restriction, input_layer_name, county_nimi_field, state_nimi_field)
        list_functions.insert_values_to_listView_object(viewItem_state,sorted_values) 
        #viewItem_state.addItems(sorted_values)
        #viewItem_state.update()
        
        expression_before = shp_tools._builds_universal_query_based_restrictions(
                            
                            county_nimi_field, 
                            state_nimi_field,
                            city_nimi_field,
                            county_restriction, 
                            state_restrictions, 
                            city_restrictions_before
                            )
        
        layer.setSubsetString(expression_before)
        layer.triggerRepaint()
        layer.updateExtents()
        shp_tools.activateLayer_zoomTo(layer)
        item_count = shp_tools.count_items_in_layer(input_layer_name)
        self.lblCount.setText(f"{item_count}")
        self.pbDone_State.show()
        self.cbChooseAll_States.show()
        
    def get_city_list(self):
        self.sw_HM.setCurrentIndex(3)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
        self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(3)
        layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]
        
        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()
        layer.blockSignals(False)
        
        hide_buttons = [ 
                        self.pbDoneCity,
                        self.pbConfirm_action,
                        self.pbCancel_streets_reset,
                        self.pbConfirm_streets_action]
        
        list_views = [ 
                        self.listWidget_City]
        
        checkboxes = [
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                        self.tblvResults_Confirm]

        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)
        
        viewItem_county = self.listWidget_county
        viewItem_state = self.listWidget_State
        viewItem_city = self.listWidget_City
            
        # When calling functions in other classes, pass object names as strings
        
        item_county = viewItem_county.currentItem()
        item_state = viewItem_state.selectedItems()
        item_city = viewItem_city.selectedItems()

        county_restriction = item_county.text() if item_county is not None else ""
        state_restrictions_before = ""
        state_restrictions = "', '".join([item.text() for item in item_state]) if item_state else ""
        #print(f"Selected items state: {state_restrictions}")
        city_restrictions = "', '".join([item.text() for item in item_city]) if item_city else ""
        #print(f"Selected items city: {city_restrictions}")

        if item_county is None:
            #print("print")
            text = HoiatusTexts().omavalitsus_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)
        else:
            
            expression_before = shp_tools._builds_universal_query_based_restrictions(
                                
                                county_nimi_field, 
                                state_nimi_field,
                                city_nimi_field,
                                county_restriction, 
                                state_restrictions_before, 
                                city_restrictions
                                )
            
            layer.setSubsetString(expression_before)
            layer.triggerRepaint()
            layer.updateExtents()
            #print(f"Expression before {expression_before}")
            # Check if any items are selected
            if item_state:
                # Retrieve and print the text of selected items
                items_name_state = [item.text() for item in item_state]
                #print(f"Selected items: {items_name_state}")
            else:
                text = HoiatusTexts().linn_kyla_valimata
                heading = Headings().warningSimple
                ModernMessageDialog.Info_messages_modern(heading, text)
                #print("No items selected")
                return

            item_count_before = shp_tools.count_items_in_layer(input_layer_name)    
            city_list = shp_tools.create_item_list_with_MultyWhere(item_count_before, items_name_state, input_layer_name, state_nimi_field, city_nimi_field)
            list_functions.insert_values_to_listView_object(viewItem_city, city_list)
            #viewItem_city.update()

            expression = shp_tools._builds_universal_query_based_restrictions(
                                
                                county_nimi_field, 
                                state_nimi_field,
                                city_nimi_field,
                                county_restriction, 
                                state_restrictions, 
                                city_restrictions
                                )
            
            layer.setSubsetString(expression)
            layer.triggerRepaint()
            layer.updateExtents()
            shp_tools.activateLayer_zoomTo(layer)
            item_count = shp_tools.count_items_in_layer(input_layer_name)
            self.lblCount.setText(f"{item_count}")
            self.pbDoneCity.show()
            self.cbChooseAll_Cities.show()



    #creditentials handling
    def remove_UC_data(self):
        clear_UC_data()

    def activate_line_edit(self):
        # Activate the QLineEdit for user input
        lePassword = self.lePassword
        lePassword.setFocus()
        lePassword.setCursorPosition(0)  # Set cursor position at the beginning

    def save_user_data(self, frames):
        username = save_user_name(self)
        access_token_success = get_access_token(self)
        
        if access_token_success:
            user_name, user_lastname, roles_text, has_qgis_access = UserSettings.user_data(self, username)

            # Get version number to check if it's "dev" mode
            path = PathLoaderSimple.metadata()
            version_nr = Version.get_plugin_version(path)
            lblVersion = self.lbVersionNumber
            if version_nr == 'dev':
                lblVersion.setStyleSheet("color: #bc5152;")
                lblVersion.setText(f"v.{version_nr}")
                if has_qgis_access == False:
                    self.lblUserAccessDenied.setVisible(True)
                    self.lblUserAccessDenied.setText(sisu.kasutaja_oigused_puuduvad)
                    self.lblUserAccessDenied.setStyleSheet("color: #bc5152;")
                    self.lblUserAccessDenied.setAlignment(Qt.AlignCenter)
                    self.pbLogin.setEnabled(False)
                    self.pbLogin.setStyleSheet("background-color: #bc5152;")
                    return  # Stop further execution
            else:
                lblVersion.setStyleSheet("")  # Reset to default style
                lblVersion.setText(f"v.{version_nr}")
                if has_qgis_access == False:
                    self.lblUserAccessDenied.setVisible(True)
                    self.lblUserAccessDenied.setText(sisu.kasutaja_oigused_puuduvad)
                    self.lblUserAccessDenied.setStyleSheet("color: #bc5152;")
                    self.lblUserAccessDenied.setAlignment(Qt.AlignCenter)
                    self.pbLogin.setEnabled(False)
                    self.pbLogin.setStyleSheet("background-color: #bc5152;")
                    return  # Stop further execution

            self.lbNuserName.setText(user_name)
            self.lblNUserSurename.setText(user_lastname)
            self.lblUserRoles.setText(roles_text)
            self.UC_Main_Frame.setVisible(False)
            FrameHandler.show_multiple_frames(self, frames)
            self.set_start_page_based_on_toggle_and_preferred_settings()
            self.resize(1150, 700)

        else:
            heading = pealkiri.warningCritical
            text = sisu.vigane_voti
            ModernMessageDialog.Info_messages_modern(heading, text)

    def set_start_page_based_on_toggle_and_preferred_settings(self):
        index = SettingsDataSaveAndLoad.load_user_prefered_startpage_index(self)            
        # Convert index to integer, handling potential exceptions
        index_int = int(index)

        toggle_value = StoreValues_Toggle().get_toggle_status()
            # Get the mapped functions dictionary from WidgetInfo
        mapped_functions = WidgetInfo.mapped_indexes_functions(self, state=toggle_value)
            #print(f"mapped_functions:  {mapped_functions}")
            # Check if mapped_functions is not None before iterating
        if mapped_functions is not None and index_int in mapped_functions:
            function = mapped_functions.get(index_int)
            if function:
                    #print(f"mapped index function: {function}")
                function()
            else:
                    # Handle the case where the mapped function is None
                print(f"No function mapped for index {index_int}. Setting default to page 5.")
                self.swWorkSpace.setCurrentIndex(5)
                self.sw_HM.setCurrentIndex(0)
        else:
                # Handle the case where index is not a valid page index (e.g., set a default)
            print(f"Invalid page index: {index_int} or mapped_functions is None. Setting default to page 5.")
            self.swWorkSpace.setCurrentIndex(5)
            self.sw_HM.setCurrentIndex(0)

    def print_UC_data(self):
        print_result(self)    

    def layer_setup(self):
        #print("started 'layer_setup'")
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        SetupCadastralLayers.load_layer_settings_widget(self, lblcurrent_main_layer_label,lblnewCadastrals_input_layer_label,lblSHPNewItems)
        
    def set_layer_settings_labels(self):
        #load = SettingsDataSaveAndLoad()
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        lblLayerProjects_Properties = self.lblLayerProjects_Properties
        lblProjectsFolder_location = self.lblProjectsFolder_location
        lblProjectsTargetFolder_location = self.lblProjectsTargetFolder_location
        lbl_preferred_project_status = self.lbl_preferred_project_status
        lbl_preferred_contract_status = self.lbl_preferred_contract_status
        lblPreferredContractsTypes_value = self.lblPreferredContractsTypes_value

        load.startup_label_loader(lblcurrent_main_layer_label,lblnewCadastrals_input_layer_label,
                                    lblSHPNewItems, lblLayerProjects_Properties, lblProjectsFolder_location,
                                    lblProjectsTargetFolder_location, lbl_preferred_project_status, 
                                    lbl_preferred_contract_status, lblPreferredContractsTypes_value)        



    def generate_virtual_mapLayer_synced_with_Mailabl(self):
        # Create an instance of YourClas
        lblFor_Sync_GreatLayerName = self.leText_For_Sync_GreateLayerName
        frSync_Cadastrals_Main = self.frSync_Cadastrals_Main
        county_list_widget = self.lwSync_County_Names
        state_list_widget = self.lwSync_State_Names
        city_list_widget = self.lwSync_City_Names
        pBar_County_list = self.pBar_Sync_County
        pBar_State_list = self.pBar_State_list 
        pBar_City_list = self.pBar_City_list
        pBar_City_items = self.pBar_CityItems
        lblSync_General = self.lblSync_General
        lblSync_General_aditional = self.lblSync_General_aditional
        lblFor_pBar_County_list = self.lblFor_pBar_Sync_County
        lblFor_pBar_State_list = self.lblFor_pBar_State_list 
        lblFor_pBar_City_list = self.lblFor_pBar_City_list
        lblFor_pBar_City_items = self.lblFor_pBar_CityItems
        Sync_Cadastrals = self.Sync_Cadastrals
        frSync_Overview_Main = self.frSync_Overview_Main
        frSync_Tools = self.frSync_Tools
        a = self.a
        b= self.b
        c = self.c
        d = self.d
        
        self.your_instance = PropertiesBaseMap(lblFor_Sync_GreatLayerName, frSync_Cadastrals_Main, county_list_widget,
                state_list_widget, city_list_widget, pBar_County_list, pBar_State_list,
                pBar_City_list, pBar_City_items, lblSync_General, lblSync_General_aditional,
                lblFor_pBar_County_list, lblFor_pBar_State_list, lblFor_pBar_City_list,
                lblFor_pBar_City_items, Sync_Cadastrals, frSync_Overview_Main, frSync_Tools, a, b, c, d)
        # Connect the button click signal to the prepare_items_for_base_map method
        self.your_instance.prepare_items_for_base_map()

#TODO -  move to projects list!        
    def update_tblMailabl_projects(self):
        button = self.pbRefresh_tblMailabl_projects
        button.blockSingnals = True
        table = self.tblMailabl_projects
        model = table.model()
        if model is not None:
            model.removeRows(0, model.rowCount())
        comboBox = self.cmbProjectStatuses
        statusValue = GetValuesFromComboBox._get_selected_status_id_from_combobox(comboBox)
        Projects.load_projects_by_status(table, statusValue)
        button.blockSingnals = False
        
    def Delete_reset_stage(self):
        DeletProcessUIActions.Delete_process_view_on_countyListView_click(self)
        
    def Delete_reset_to_stage_state(self):
        DeletProcessUIActions.Delete_process_view_after_state(self)
        self.pbDel_City.hide()
        self.lwDelete_Cities_Names.clear()
    
    def delete_process_after_county(self):
        lwDel_County_Names = self.lwDelete_County_Names
        lwDel_State_names = self.lwDel_State_Names
        lwDel_City_Names = self.lwDelete_Cities_Names

        check_items = lwDel_County_Names.selectedItems()
        if not check_items:
            DeletProcessUIActions.Delete_process_view_after_unsuccessful_county(self)
            # No item selected, perform your desired action here
            text = HoiatusTexts().maakond_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading,text)

            
        else:
            # Item selected, continue with your process        
            lbl = self.lblDel_Amount
            DeletProcessUIActions.Delete_process_view_after_county(self)
            
            button_to_activate = self.pbDel_County
            activ_cadastral_layer = SettingsDataSaveAndLoad().load_target_cadastral_name()
            
            MapRestictionsAndListWidgetDataInserion.get_state_list(button=button_to_activate,
                                  layer_name=activ_cadastral_layer,
                                    state_field = state_nimi_field,
                                    county_field = county_nimi_field,
                                    lwDel_County_Names = lwDel_County_Names, 
                                    lwDel_State_names = lwDel_State_names,
                                    lbl=lbl
                                    )
            
    def delete_process_after_state(self):
        lwDel_County_Names = self.lwDelete_County_Names
        lwDel_State_names = self.lwDel_State_Names
        lwDel_City_Names = self.lwDelete_Cities_Names
        
        check_items = lwDel_State_names.selectedItems()
        if not check_items:
            DeletProcessUIActions.Delete_process_view_after_unsuccessful_state(self)
            # No item selected, perform your desired action here
            text = HoiatusTexts().omavalitsus_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)

        else:
            DeletProcessUIActions.Delete_process_view_after_state(self)

            lbl = self.lblDel_Amount        
            button = self.pbDel_State
            activ_cadastral_layer = SettingsDataSaveAndLoad().load_target_cadastral_name()
            f_delete.DeleteProcess_get_city_list(button, activ_cadastral_layer, 
                                                state_nimi_field, 
                                                city_nimi_field,
                                                lwDel_State_names,
                                                lwDel_City_Names,
                                                lbl
                                                )
            
            
    def delete_process_after_city(self):

        tbl_streets = self.tbl_Delete_streets
        tbl_properties = self.tbl_Delete_properties

        lwDel_County_Names = self.lwDelete_County_Names
        lwDel_State_names = self.lwDel_State_Names
        lwDel_City_Names = self.lwDelete_Cities_Names
        total_count_label = self.lblDel_Amount        
        button = self.pbDel_City
        tab_widget = self.tabW_Delete_list
        TabHandler.tabViewByState(tab_widget,state=True)
        button.blockSignals(True)
        
        check_items = lwDel_State_names.selectedItems()
        if not check_items:
            DeletProcessUIActions.Delete_process_view_after_unsuccessful_city(self)
            # No item selected, perform your desired action here
            text = HoiatusTexts().omavalitsus_valimata
            heading = Headings().warningSimple
            ModernMessageDialog.Info_messages_modern(heading, text)

        else:
            DeletProcessUIActions.Delete_process_view_after_city(self)
            button = self.pbDel_City
            
            layer_name = SettingsDataSaveAndLoad().load_target_cadastral_name()
            #print(f"shp_input_layer_name {layer_name}")
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            #TODO rethink signal blocking!
            layer.blockSignals(True)
            # Deselect all selected items on the map
            layer.removeSelection()
            layer.blockSignals(False)
            
            County_Names =   lwDel_County_Names.currentItem()
            State_names = lwDel_State_names.selectedItems()
            City_Names = lwDel_City_Names.selectedItems()
            
            county_restriction = County_Names.text() if County_Names is not None else ""
            state_restrictions = "', '".join([item.text() for item in State_names]) if State_names else ""
            #print(f"Selected items state: {state_restrictions}")
            city_restrictions = "', '".join([item.text() for item in City_Names]) if City_Names else ""
            #print(f"Selected items city: {city_restrictions}")
            self.tabW_Delete_list.setCurrentIndex(0)  
            self.tabW_Delete_list.show()
            DeletProcessUIActions.Delete_process_view_after_city(self)
            #Clean code in universal map simplifier because it creates only expression 
            expression = shp_tools._builds_universal_query_based_restrictions(
                                
                                county_nimi_field, 
                                state_nimi_field,
                                city_nimi_field,
                                county_restriction, 
                                state_restrictions, 
                                city_restrictions
                                )
            # Disable signals for the layer        
            layer.setSubsetString(expression)
            layer.triggerRepaint()
            layer.updateExtents()
            layer.blockSignals(True)
            layer.selectAll()    
            shp_tools.activateLayer_zoomTo(layer)
            properties_model, streets_model, total = table_functions.generate_table_from_selected_map_items_with_roads(layer_name)
            
      
            inserter = TableDataInserter()
            inserter.insert_data_to_tables(
            tables_with_models = [
                (tbl_streets, streets_model),
                (tbl_properties, properties_model)
                    ],
                 total=total,
                 total_label=total_count_label
             )

            
            layer.blockSignals(False)
            
        UIDeleteCheckboxes.checkboxes_on_after_city(self)
        button.blockSignals(False)

    def DeleteProcess_check_validity_in_Mylabl (self):

        DeleteActions.delete_selected_items_from_mylabl(self)
        
    def toggle_settings_main_view(self):
        self.swWorkSpace.setCurrentIndex(4)
        self.sw_HM.setCurrentIndex(4)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
        widget = self.pbSettings_SliderFrame   
        
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        lblLayerProjects_Properties = self.lblLayerProjects_Properties
        lblProjectsFolder_location = self.lblProjectsFolder_location 
        lblProjectsTargetFolder_location = self.lblProjectsTargetFolder_location
        lbl_preferred_project_status = self.lbl_preferred_project_status
        lbl_user_name = self.lbNuserName
        lbl_preferred_contract_status = self.lbl_preferred_contract_status 
        lblPreferredContractsTypes_value = self.lblPreferredContractsTypes_value
        lblPreferredFolderName_structure = self.lblPreferredFolderName_structure
        prefered_folder_structure_value = SettingsDataSaveAndLoad.load_projects_prefered_folder_name_structure(self)
        lblPreferredFolderName_structure.setText(prefered_folder_structure_value)
        lblPreferredEasementsStatus = self.lblPreferredEasementsStatus
        PreferredEasementsStatus_Value = SettingsDataSaveAndLoad.load_easements_status_names(self)
        lblPreferredEasementsStatus.setText(PreferredEasementsStatus_Value)
        lblPreferredEasementsTypes_value = self.lblPreferredEasementsTypes_value
        PreferredEasementsTypes_values = SettingsDataSaveAndLoad.load_easements_type_names(self)
        lblPreferredEasementsTypes_value.setText(PreferredEasementsTypes_values)
        prefered_homepage_name_value = SettingsDataSaveAndLoad.load_user_prefered_startpage_name(self)
        if prefered_homepage_name_value == "":
            self.lblSettings_preferedHomePage.setText("Määramata")
        else:
            self.lblSettings_preferedHomePage.setText(prefered_homepage_name_value)
        
        water_layer_name = SettingsLoader.get_setting( LayerSettings.WATER_LAYER)
        sewer_layer_name = SettingsLoader.get_setting( LayerSettings.SEWER_LAYER)
        pressure_sewer_layer_name = SettingsLoader.get_setting( LayerSettings.PRESSURE_SEWER_LAYER)
        drainage_layer_name = SettingsLoader.get_setting( LayerSettings.DRAINAGE_LAYER)
        
        self.lblWaterPipesValue.setText(water_layer_name)
        self.lblSewerPipesValue.setText(sewer_layer_name)
        self.lblPrSewagePipesValue.setText(pressure_sewer_layer_name)
        self.lblDrainagePipesValue.setText(drainage_layer_name)

        SettingsDataSaveAndLoad.startup_label_loader(self, lblcurrent_main_layer_label,lblnewCadastrals_input_layer_label,
                                                        lblSHPNewItems, lblLayerProjects_Properties,lblProjectsFolder_location, 
                                                        lblProjectsTargetFolder_location, lbl_preferred_project_status, 
                                                        lbl_preferred_contract_status, lblPreferredContractsTypes_value)

        
        #if Flags.Flag_settings_button:
        #print("toggle if")
        WidgetAnimator.toggle_Frame_height_for_settings(self, widget)
            #widget.setMaximumHeight(16777215)
            #QTimer.singleShot(600, lambda: WidgetAnimator.toggle_Frame_height_for_settings(self, widget))
        #else:
        #    print("toggle else")
            #secondLevelButtonsHandler.toggle_Frame_height_DataLoading(self)
            #secondLevelButtonsHandler.toggle_Frame_height_Cadaster_functions(self)
            #widget.setMaximumHeight(0)
        Flags.Flag_settings_button = not Flags.Flag_settings_button
        print(f"Flags: {Flags.Flag_settings_button}")
        

#########################################################################################################################

                    #new section to be implemented into Mailabl plugin 

#########################################################################################################################

    def get_connected_signal(self):
        listWidgets = [self.lvCounty, self.lvState, self.lvSettlement]
        for widget in listWidgets:
            widget.setEnabled(False)
        element = self.sender()
        CacheUpdater.update_slected_items_cache(element)
        
        UI = UIStateManager(self)
        
        UI.flow_and_ui_controls()

        for widget in listWidgets:
            widget.setEnabled(True)

    def setup_button_actions(self):
        self.label_5.setVisible(False)
        self.pbtest_2.setVisible(True)

        loader = SHPLayerLoader(self)
        UI = UIStateManager(self)
        
        
        """Setup button-action mapping and connections."""
        self.button_actions = {
            self.btnAddElements: partial(SelectionActions.main_process_control, Processes.ADD, self.btnAddElements),
            self.btnUpdateData: partial(SelectionActions.main_process_control, Processes.EDIT, self.btnUpdateData),
            self.btnRemoveItems: partial(SelectionActions.main_process_control, Processes.REMOVE, self.btnRemoveItems),
            self.pbConfirmAction: partial(SelectionActions.execute_action),
            self.pbCancelAction: SelectionActions.cancel_selection,
            #self.pbConfirmAction : AddProperties.store_to_archive,
            self.pbLoaddShapeFile:loader.load_shp_layer,
            self.pbOpenMaAmet:partial(loadWebpage.open_maa_amet_webpage_new),
            self.pbtest_2: self.see_loaded_layers,
            self.btnMapActions: UI.start_properti_flow_main
        }

        for button, function in self.button_actions.items():
            button.clicked.connect(function)

    def on_toggle_all_with_list(self, state):
        checkbox = self.sender()
        widget_name = checkbox.property("target_widget")
        widget = getattr(self, widget_name, None)
        if widget is not None:
            if state == Qt.Checked:
                ListSelections.select_all_items(widget)
            else:
                ListSelections.deselect_all_items(widget)

    def on_toggle_all_with_Table(self, state):
        checkbox = self.sender()
        widget_name = checkbox.property("target_widget")
        widget = getattr(self, widget_name, None)
        if widget is not None:
            if state == Qt.Checked:
                TableHelper.select_all_items(widget)
            else:
                TableHelper.deselect_all_items(widget)

    def on_toggle_select_only_non_transport_properties(self, state):
        checkbox = self.sender()
        widget_name = checkbox.property("target_widget")
        widget = getattr(self, widget_name, None)
        search_field = 'siht1'
        search_value = 'TRANSPORDIMAA'
        if widget is not None:
            if state == Qt.Checked:
                feature_ids = TableHelper.select_items_by_field(table=widget, field=search_field, search_value=search_value)
                MapToolsHelper.select_features_by_ids(feature_ids=feature_ids, zoom_to=True)
                checkbox.setText("Vali kõik")
            else:
                TableHelper.select_all_items(widget)
                feature_ids = TableHelper.get_selected_feature_ids_from_table_model(widget)
                MapToolsHelper.select_features_by_ids(feature_ids=feature_ids, zoom_to=True)
                checkbox.setText("Eemalda tranpordimaa valikust")

    @staticmethod
    def see_loaded_layers():
        stored_layers_settings = PropertiesProcessStage.loaded_layers
        print("loaded layer settings are")
        print(stored_layers_settings)
        