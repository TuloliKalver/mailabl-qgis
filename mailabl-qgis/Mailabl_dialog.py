# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MailablDialog
                                 A QGIS plugin
 Mailabl
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-07-04
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Kalver Tammik/Tuloli OÜ
        email                : tulolikt@gmail.com
 ***************************************************************************/

"""
import time
import os

from .app.web import loadWebpage
from .app.workspace_handler import WorkSpaceHandler, TabHandler
from PyQt5.QtWidgets import  QLineEdit, QListView, QMessageBox

#from .config.ui_directories import Path_loader_simple,PathLoader, plugin_dir_path, UI_multiline_Statusbar
from .config.settings import DataSettings, SettingsDataSaveAndLoad
from .config.layer_setup import Setup_CadastralsLayers, Setup_ProjectLayers
from .config.settings import connect_settings_to_layer, flags, settingPageElements

from qgis.core import QgsProject
from qgis.PyQt.QtWidgets import QMessageBox, QTableView, QAbstractItemView, QHeaderView
from qgis.PyQt import QtWidgets, uic
from qgis.utils import iface
from PyQt5.QtCore import QTimer
from .app.checkable_comboboxes import ComboBox_functions, shp_tools
from .app.functions import QGIS_items
from .app.remove_processes import ReomveProcess
from .app.ui_controllers import FrameHandler, WidgetAnimator, secondLevelButtonsHandler, color_handler, stackedWidgetsSpaces, alter_containers, LayerChecker
from .app.View_tools import listView_functions, shp_tools, tableView_functions, progress, ToolsProject
from .Functions.item_selector_tools import CadasterSelector, properties_selectors
from .Functions.SearchEngines import General
from .Functions.delete_items import DeletingProcesses, delete_buttons, delete_listViews, delete_tables, delete_checkboxes, Delete_Main_Process, Delete_finalProcess
from .Functions.Tools import tableFunctions
from .Functions.add_items import Add_Properties_final
from .Functions.propertie_layer.properties_layer_data import PropertieLayerFunctions
from .Functions.layer_generator import LayerCopier
#from .messages import *
from .processes.ImportProcesses.Import_shp_file import SHPLayerLoader
from .processes.OnFirstLoad.FirstLoad import Startup
from .queries.python.access_credentials import (clear_UC_data,
                                                get_access_token, print_result,
                                                save_user_name)
from .queries.python.projects import Projects
from .queries.python.update_relations.update_project_properties import ProjectsProperties,map_selectors
from .queries.python.property_data import Properties, deleteProperty, add_properties, MyLablChecker
from .app.checkable_comboboxes import ComboBox_functions
from .widgets.ui_loader_advanced import loader
from PyQt5.QtWidgets import QMessageBox
from .processes.SyncProperties.syncMailablProperties import PropertiesBaseMap
from PyQt5.QtCore import QCoreApplication
from PyQt5.QtWidgets import QListWidgetItem
from .Functions.AddProperties.AddNonduplicateItems import AddProperties
from .Functions.RemoveProperties.RemoveSelectedProperties import DeleteActions




# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Mailabl_dialog_base.ui'))

###############################################################################################################
# Set plugin_dir as a class variable
plugin_dir = os.path.dirname(__file__)


################################################################################################################
#initialize
comboboxes = ComboBox_functions()
process = ReomveProcess()
color = color_handler()
list_functions = listView_functions()
table_functions = tableView_functions()
graph_tools = shp_tools()
properties_functions = Properties()

setting_layer = connect_settings_to_layer
selector_class = properties_selectors()
projects = CadasterSelector()
progress_bar = progress
select_from_aLayer = map_selectors

load = SettingsDataSaveAndLoad()
stacked_widgets = stackedWidgetsSpaces()
checker = MyLablChecker()
table_data = tableFunctions
f_delete = DeletingProcesses()


#set parameters

input_layer_name = load.load_SHP_inputLayer_name()

county_nimi_field = 'MK_NIMI'
state_nimi_field = 'OV_NIMI'
city_nimi_field = "AY_NIMI"


#set statical overall parameters
# Change name if difrent widgets are used in animation definitions 
#dimensions
qwFrameMinHeight1 = 0 #sets min height of widget
qwFrameTopMargin1 = 10 #sets TopMargin of a widget
qwFrameBottomMargin1 = 10 #sets BottomMargi of a widget
button_padding = 6  # sets padding button spacing

################################################################################################################

class MailablDialog(QtWidgets.QDialog, FORM_CLASS):
    
################################################################################################################

    def __init__(self, parent=None):
        """Constructor."""
        super(MailablDialog, self).__init__(parent)
        
        # Rest of your __init__ method...
        # Call the function to create the necessary layer structure
        on_load = Startup()
        on_load.FirstLoad()
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

    #connect graphQL endpoint
   
    #Creat instances
#TODO does this greate problems issue created at 080124
        self.data_settings = DataSettings()


        self.setupUi(self)

        self.sw_HM.setCurrentIndex(0)
        initial_size = self.UC_Main_Frame.size()
        self.resize(initial_size.width()+5, initial_size.height()+5)

        # Hide typing password
        self.lePassword.setEchoMode(QLineEdit.Password)
        self.widget_19.setVisible(False)
        self.pbUC_print.setVisible(False)
                
        #self.widget_animator = WidgetAnimator(self)

        
        # declaring Delete process elements    
        pbDel_State = self.pbDel_State
        pbDel_city =  self.pbDel_City
        pbDel_PreConfirm = self.pbDel_PreConfirm


        self.f_delete_lists = delete_buttons(pbDel_State, pbDel_city, pbDel_PreConfirm)

        lwDel_State_Names = self.lwDel_State_Names
        lwDelete_Cities_Names = self.lwDelete_Cities_Names
        lwDelete_County_Names = self.lwDelete_County_Names
        self.f_delete_views = delete_listViews(lwDel_State_Names, lwDelete_Cities_Names, lwDelete_County_Names)

        cbDel_ChooseAll_Data_properties = self.cbDel_ChooseAll_Data_properties
        cbDel_ChooseAll_Data_include_Allroads = self.cbDel_ChooseAll_Data_include_Allroads
        cbDel_ChooseAll_Data_transport = self.cbDel_ChooseAll_Data_transport
        cbDel_ChooseAll_States = self.cbDel_ChooseAll_States
        cbDel_ChooseAll_Cities = self.cbDel_ChooseAll_Cities
        self.f_delete_checkboxes = delete_checkboxes(cbDel_ChooseAll_Data_properties, cbDel_ChooseAll_Data_include_Allroads, 
                                                    cbDel_ChooseAll_Data_transport, cbDel_ChooseAll_States, cbDel_ChooseAll_Cities)
        
        tbl_Delete_streets = self.tbl_Delete_streets
        tbl_Delete_properties = self.tbl_Delete_properties
        self.f_delete_tables = delete_tables(tbl_Delete_streets, tbl_Delete_properties)
        
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        lblLable_14= self.label_14
        lblLayerProjects_Properties = self.lblLayerProjects_Properties


        settingPageElements(lblcurrent_main_layer_label, lblnewCadastrals_input_layer_label, lblSHPNewItems, lblLable_14, lblLayerProjects_Properties)
        
    
    # Call the repair_tommorrow function when the widget is loaded
        self.set_layer_settings_labels()
    
    #setup login dialog and hide frames to block functionality!
        self.on_load()
        #self.startLayerListener()
        
        object_listView_Add_State = self.listWidget_State
        object_listView_Add_State.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        
        object_listView_Add_City = self.listWidget_City
        object_listView_Add_City.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys

        object_tableView_Add_Properties_list = self.tblvResults_Confirm
        object_tableView_Add_Street_list = self.tblvResults_streets_Confirm


        #Listen to input map selection change and fill table!
        #input_layer_name = SettingsDataSaveAndLoad.load_SHP_inputLayer_name(self)
        #self.input_layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        #self.input_layer.selectionChanged.connect(table_functions.generate_table_from_selected_map_items(view_item=self.tblvResults_Confirm,total=graph_tools.count_selected_items_in_layer()))
        #self.input_layer.selectionChanged.connect(self.runningactions)
    
        # Set the initial icon for the button
        #self.icon_visible = QIcon(u":/icons/Icons_hele/chevron-up.svg")  # Replace "icon_hide.png" with the desired icon
        #self.icon_hidden = QIcon(u":/icons/Icons_hele/chevron-down.svg")  # Replace "icon_show.png" with the desired icon

        #self.tblvResults_Confirm.selectionChanged.connect(lambda: self.update_layer_based_on_table(self.tblvResults_Confirm))
        #if self.tblvResults_Confirm is not None:
        #    selection_model = self.tblvResults_Confirm.selectionModel()
        #    if selection_model is not None:
        #        selection_model.selectionChanged.connect(lambda: self.update_layer_based_on_table(self.tblvResults_Confirm))
                
        #Assuming 'tableView' is your QTableView object
        #self.tblvResults_Confirm.selectionModel().selectionChanged.connect(self.handleSelectionChanged)


#Define buttons
        self.pbCadasters = self.pbCadasters
        self.pbAdd_SHP_To_Project = self.pbSettings_AddShapeFile
        self.pbAvaMaaameti_veebikas = self.pbAvaMaaAmet
        self.Start_update = self.pbUpdateData
        

    #Confirm password entering
        self.pbUC_Save.clicked.connect(self.save_user_data)
        self.lePassword.returnPressed.connect(self.save_user_data)
        
        self.pbUC_print.clicked.connect(self.print_UC_data)
        self.pbUC_Cancel.clicked.connect(self.remove_UC_data)
        #self.pbConnectNew.clicked.connect(self.token)


    # Kinnitusnupud
        # Edasi liikumised
        #self.pbKinnitaMaakond.clicked.connect(self.Maakond_Valitud)
        #self.pbKinnitaOmavalitsus.clicked.connect(self.Omavalitsus_Valitud)
        #self.pbKinnitaKylad.clicked.connect(self.kyladValitud)
    


    # Menüü lülitid
        #eelseaded

        # Peamenüü
    
        #self.QWidget_Sub_Menu.setVisible(False)

# Opens and handles the sub menu
        
        self.pbCadasters.clicked.connect(self.pb_Cadasters_change_help)
        self.pbCadasters.clicked.connect(lambda: secondLevelButtonsHandler.toggle_Frame_height_Cadaster_functions(self))
        self.pbUpdateData.clicked.connect(lambda: secondLevelButtonsHandler.toggle_Frame_height_DataLoading(self))
        #self.pbActivateLabelSettings.clicked.connect(self.SaveToLabel)


        self.pbSubstitutes.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Substitutes_FrontPage(self))
        self.pbContracts.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Contracts_FrontPage(self))
        self.pbMapThemes.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_MapThemes_FrontPage(self))
        self.pbAddDrawings.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_AddDrawings_FrontPage(self))
        
        #Uuendamise nupud need vajavad uuendamist ja tuleb välja töötada uus loogika
    
    
    #TODO Arendusnupp ära koristada
    
    
    
        self.pbSyncMailabl.clicked.connect(lambda: WorkSpaceHandler.Open_generate_mapLayer_synced_with_Mailabl_first_page(self))
    #TODO rewriting generate base layer process!
        self.pbSync_start_sync.clicked.connect(self.generate_virtual_mapLayer_synced_with_Mailabl)
        
        
        self.pbRefresh.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Refresh(self))
    
        self.pbExpand.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Expand(self))
    
        self.pbRemove.clicked.connect(lambda: WorkSpaceHandler.swDeleteworkspace(self))


    # Setting processes 

        self.pbSettings.clicked.connect(self.toggle_settings_main_view)
        #Add shae files
        self.pbSettings_AddShapeFile.clicked.connect(self.load_cadastrals) #pbLisaShpFail
        
    # workspace page ID 5 = Homepage
        self.pbHome.clicked.connect(lambda: WorkSpaceHandler.swWorkSpace_Home(self))

        
    # workspace page ID 7 = Projects
        self.pbProjects.clicked.connect(lambda: WorkSpaceHandler.swWorkspace_Projects(self))
        self.pbRefresh_tblMailabl_projects.clicked.connect(self.update_tblMailabl_projects)
        
        
        self.pbShowOnMap.clicked.connect(self.show_projects_on_map_with_cadastral_connection)
        self.pbProjects_Connect_properties.clicked.connect(self.connect_properties_with_projects)

        
        
        # Logo ja kodukas
        self.pbMailabl.clicked.connect(lambda: loadWebpage.open_Mailabl_homepage())
        


    # Katastri andmete kontrollimine 
        self.pbUpdateData.clicked.connect(lambda: WorkSpaceHandler.show_help_update(self))
        #self.pbRefresh.clicked.connect(self.check_for_updates)
        
        #Setting workspace buttons and functions
        self.pbLayerSettings.clicked.connect(self.layer_setup)
        self.pbSettings_Setup_Projects.clicked.connect(lambda: Setup_ProjectLayers.load_project_settings_widget(self))
        
    # Avab maa-ameti repositooriumi kaardiandmete alla laadimiseks
        self.pbAvaMaaAmet.clicked.connect(lambda: loadWebpage.Open_MaaAmet_webpage(self))
        
        
        
###########################################
    #process buttons in develepment 
    
        #self.listWidget_county.itemClicked.connect(self.get_state_list)
        self.pbDone_County.clicked.connect(self.get_state_list)
        self.pbDone_State.clicked.connect(self.get_city_list)
        self.pbDoneCity.clicked.connect(self.prepare_properties_list_and_Add_to_table_updated_with_selecting_items)

        
        
        #self.listWidget_county_2.itemClicked.connect(self.get_state_list_2)
        #self.pbDone_State_2.clicked.connect(self.get_city_list_2)
        #self.pbDoneCity_2.clicked.connect(self.prepare_properties_list_2)
        
        self.pbDel_County.clicked.connect(self.delete_process_after_county)
        pbDel_State.clicked.connect(self.delete_process_after_state)
        pbDel_city.clicked.connect(self.delete_process_after_city)

        pbDel_PreConfirm.clicked.connect(self.DeleteProcess_check_validity_in_Mylabl)
        
        lwDelete_County_Names.clicked.connect(self.Delete_reset_stage)
        lwDel_State_Names.clicked.connect(self.Delete_reset_to_stage_state)
        
        #self.pbDelete_items_getCounty.clicked.connect(self.get_Mailabl_existing_counties)
        
        
    
    #Adding and removing
        
        self.pbSendItemstoMailabl.clicked.connect(self.add_selected_items_2)
        
        self.pbSearch_Add.clicked.connect(lambda: General.search_cadastral_items_by_values(self))




        
    #update selections in adding proccess
        self.cbChooseAll_States.stateChanged.connect(lambda state, view_state=object_listView_Add_State: list_functions.toggleListSelection(view_state, state))
        self.cbChooseAll_Cities.stateChanged.connect(lambda state, view_state=object_listView_Add_City: list_functions.toggleListSelection(view_state, state))
        self.cbChooseAllAdd_properties.stateChanged.connect(lambda state, view_state=object_tableView_Add_Properties_list: list_functions.toggleListSelection(view_state, state))
        self.cbChooseAllAdd__street_properties.stateChanged.connect(lambda state, view_state=object_tableView_Add_Street_list: list_functions.toggleListSelection(view_state, state))
        self.cbOnPropertiesTab_Include_streets.stateChanged.connect(lambda state, view_state=object_tableView_Add_Street_list: list_functions.toggleListSelection(view_state, state))

        self.tblvResults_Confirm.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tblvResults_streets_Confirm.setSelectionBehavior(QAbstractItemView.SelectRows)

#TODO - Delete - remove line of code
    #update selections in deleting proccess
        self.cbDel_ChooseAll_States.stateChanged.connect(lambda state, view_name=lwDel_State_Names: list_functions.toggleListSelection(view_name, state))
        self.cbDel_ChooseAll_Cities.stateChanged.connect(lambda city, view_name=lwDelete_Cities_Names: list_functions.toggleListSelection(view_name, city))
        self.cbDel_ChooseAll_Data_properties.stateChanged.connect(lambda state, view_state=tbl_Delete_properties: list_functions.toggleListSelection(view_state, state))
        self.cbDel_ChooseAll_Data_transport.stateChanged.connect(lambda state, view_state=tbl_Delete_streets: list_functions.toggleListSelection(view_state, state))
        
        tbl_Delete_properties.setSelectionBehavior(QAbstractItemView.SelectRows)
        tbl_Delete_streets.setSelectionBehavior(QAbstractItemView.SelectRows)

        
        self.pbCooseFromMap_Add.clicked.connect(self.manualy_choose_properties_to_Add)
        
        self.listWidget_county.clicked.connect(self.update_map_with_restricted_county)
        self.listWidget_State.clicked.connect(self.update_step_2)
        self.listWidget_City.clicked.connect(self.update_step_3)
        
        
        self.pbConfirm_action.clicked.connect(self.StartImportProcess)

        self.pbMainMenu.clicked.connect(self.handleSidebar_leftButtons)
        
        

############sort/cler/delete##############################
        
        
        #self.cbChooseAll_States.clicked.connect(self.togle_items_selection_State)
        #self.cbChooseAll_States.stateChanged.connect(list_functions.toggleListSelection(list_view_state))
        
        
        self.helpMenuToggle.clicked.connect(self.handleSidebar_help)
        

########################################################################

#    def handleSelectionChanged_dev(selected, deselected):
#        # Perform actions based on the newly selected items
#        for index in selected.indexes():
#            print("Selected:", index.data())

        # Perform actions based on the deselected items
#        for index in deselected.indexes():
#            print("Deselected:", index.data())


#    def update_layer_based_on_table(self):
#        print("started: 'update_layer_based_on_table'")


    def handleSidebar_help(self):
        button1 = self.pbMailabl        
        help_menu = self.helpMenu
        container = self.rightMenuContainer
        container_width = container.width()
        
        buttons = [button1]

        original_texts = {button1: " Mailabl.com"                
                        }
        new_texts = {button1: ""
                        }
        #Chose a random button to measure text lenght
        length = len(button1.text())
        alter_containers.toggle_right_menu(self, length, buttons, original_texts, new_texts, help_menu, container, container_width)


    def handleSidebar_leftButtons(self):
        button1 = self.pbSettings
        button2 = self.pbExpand
        button3 = self.pbRefresh
        button4 = self.pbRemove
        button5 = self.pbCadasters
        #button6 is free to set any new buttons       
        button7 = self.pbUpdateData
        button8 = self.pbAvaMaaAmet
        button9 = self.pbSettings_AddShapeFile
        button10 = self.pbAddDrawings
        button11 = self.pbContracts
        button12 = self.pbMainContract
        button13 = self.pbPreContacts
        button14 = self.pbHome
        button15 = self.pbMapThemes
        button16 = self.pbProjects
        button17 = self.pbSubstitutes
        button18 = self.pbSyncMailabl

        left_menu = self.leftMenuContainer
        container = self.leftMenuContainer
        container_width = container.width()
        #print(container_width)
        
        buttons = [button1, 
                button2,
                button3,
                button4,
                #button6 is free to set any new buttons
                button5,
                button7,
                button8,
                button9,
                button10,
                button11,
                button12,
                button13,
                button14,
                button15,
                button16,
                button17,
                button18]

        original_texts = {button1: "Sätted",
                            button2: "Kinnistute lisamine",
                            button3: "Andmete värskendamine",
                            button4: "Kinnistute eemaldamine",
                            button5: "Toimingud kinnistutega",
                            #button6 is free to set any new buttons
                            button7: "Andmete laadimine",
                            button8: "Maa-ametisse",
                            button9: "Lae algandmed",
                            button10: "Teostusjoonised",
                            button11: "Lepingud",
                            button12: "Teenuslepingud",
                            button13: "Liitumislepingud",
                            button14: "Avaleht",
                            button15: "Teemakaardid",
                            button16: "Projektid",
                            button17: "Servituudid",
                            button18: "Mailabliga sünkroniseerimine"
                        }

        new_texts = {button1: "",
                    button2: "",
                    button3: "",
                    button4: "",
                    button5: "",
                    #button6 is free to set any new buttons
                    button7: "",
                    button8: "",
                    button9: "",
                    button10: "",
                    button11: "",
                    button12: "",
                    button13: "",
                    button14: "",
                    button15: "",
                    button16: "",
                    button17: "",
                    button18: ""
                        }
        #Chose a random button to measure text lenght
        length = len(button18.text())
        alter_containers.toggle_left_menu(self, length, buttons, original_texts, new_texts, left_menu, container, container_width)

    def StartImportProcess(self):
        AddProperties.check_for_duplicates_and_add_only_matches(self)


    #TODO add streets!!!
    def add_selected_items(self):
        init = tableFunctions()
        table = self.tblvResults_Confirm
        table_2 = self.tabWidget_Propertie_list
        selected_indexes = table.selectionModel().selectedIndexes()
        # Set to store data
        data = set()
        
        for index in selected_indexes:
            each_data = init.extract_property_data(index, table)
            if each_data:
                data.add(f'{each_data}')
        
        data_2 =set()
        
        for index in selected_indexes:
            each_data = init.extract_property_data(index, table_2)
            if each_data:
                data_2.add(f'{each_data}')
        
        # Convert the set data to a comma-separated string
        #print(f"data before join {data}")
        data = ', '.join(data)
        #ids = [id_string]
        ids = list(data)       
        #print(f"data after join {data}")
        return data, data_2


    def update_step_2 (self):
        layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()

        hide_buttons = [ 
                self.pbDoneCity,
                self.pbConfirm_action,
                self.pbSendItemstoMailabl,
                self.pbCancel_streets_reset,
                self.pbConfirm_streets_action]
        
        list_views = [
                        self.listWidget_City]
        
        checkboxes = [
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]


        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)

    

        
    def update_step_3 (self):
        layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()

        hide_buttons = [ 
                self.pbConfirm_action,
                self.pbSendItemstoMailabl,
                self.pbCancel_streets_reset,
                self.pbConfirm_streets_action]
        
        list_views = []
        
        checkboxes = [
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]


        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)

    
    
    def update_map_with_restricted_county (self):
        input_layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]

        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()

        hide_buttons = [self.pbDone_State, 
                self.pbDoneCity,
                self.pbConfirm_action,
                self.pbSendItemstoMailabl,
                self.pbCancel_streets_reset,
                self.pbConfirm_streets_action]
        
        list_views = [self.listWidget_State, 
                        self.listWidget_City]
        
        checkboxes = [self.cbChooseAll_States,
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]

        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)

        shp_class = shp_tools
        viewItem_county = self.listWidget_county
        viewItem_state = self.listWidget_State
        viewItem_city = self.listWidget_City
        
        layer.blockSignals(False)
        shp_class.county_map_simplifier(self, county_nimi_field, input_layer_name, viewItem_county, viewItem_state, viewItem_city)

    #Functions in Development
#TODO improve listener with is activ and plugin settings conditions 
    def startLayerListener(self):
        print("started layer listener")
        input_layer_name = load.load_SHP_inputLayer_name()

        # Check if the layer with the specified name exists
        map_layers = QgsProject.instance().mapLayersByName(input_layer_name)
        if not map_layers:
            # Layer not found, do nothing and return
            return

        layer = map_layers[0]
        layer.selectionChanged.connect(lambda: self.activate_item_selection_from_layer(input_layer_name))
    
    
    def activate_item_selection_from_layer(self,layer_name):
        print("activated item selector")
        #print("started")
        self.cbChooseAllAdd_properties.setChecked(False)
        self.cbChooseAllAdd__street_properties.setChecked(False)
        
        model_without_transport, model_with_transport, total = table_functions.generate_table_from_selected_map_items_with_roads(layer_name)
        self.tblvResults_Confirm.setModel(model_without_transport)
        self.tblvResults_streets_Confirm.setModel(model_with_transport)
        self.pbConfirm_action.show()
        self.cbChooseAllAdd_properties.show()
        self.cbChooseAllAdd__street_properties.show()
        #self.cbChooseAllAdd__street_properties.setChecked(True)
        self.cbChooseAllAdd_properties.setChecked(True)
        self.cbChooseAllAdd__street_properties.setChecked(True)
        model_without_transport.clear() 
        model_with_transport.clear()

    
    
    def manualy_choose_properties_to_Add(self):
        #load = SettingsDataSaveAndLoad()
        input_layer_name = load.load_SHP_inputLayer_name()
        #print(f"shp_input_layer_name {layer_name}")
        input_layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        input_layer.blockSignals(True)
        input_layer.removeSelection()
        input_layer.blockSignals(False)
        
        
        self.tabWidget_Propertie_list.show()
        self.tabWidget_Propertie_list.setCurrentIndex(0) 
        #PropertieLayerFunctions.generate_table_from_selected_map_items_simple(self,table_view, layer_name)
            
        select_from_aLayer.activate_layer_and_use_selectTool(input_layer_name)
        #table = self.tblvResults_Confirm
        model_without_transport, model_with_transport = table_functions.generate_table_from_selected_map_items_with_roads(input_layer_name)

        # Block the signal temporarily
        self.cbChooseAllAdd_properties.blockSignals(True)
        self.cbChooseAllAdd__street_properties.blockSignals(True)

        self.tblvResults_streets_Confirm.setModel(model_with_transport)
        self.tblvResults_Confirm.setModel(model_without_transport)
        
        # Unblock the signal after setting the models
        self.cbChooseAllAdd_properties.blockSignals(False)
        self.cbChooseAllAdd__street_properties.blockSignals(False)
        
        self.cbChooseAllAdd_properties.setChecked(True)
        self.cbChooseAllAdd__street_properties.setChecked(True)
        
        
    
#TODO if all tests confirm no problems
    #def show_something_on_map_with_cadastral_connection(self):
    #    table = self.tblvResults_Confirm
    #    cadasters = projects.importProperties_return_cadasters(table) 
    #    #print(f"Returned values {cadasters}")       
    #    layer_name = "SHP_KATASTRIYKSUS"  # Replace with the actual layer name
    #    values_to_select = cadasters
    #    selector_class.selector_tool(layer_name, values_to_select)
    #    print(layer_name,values_to_select)
    #    cadasters.clear()
    
    
    

        
    #Adding properties


    #TODO remove from code in the end
    def test_aditional_details_to_properties(self):
        insertion_class = add_properties
        insertion_class.add_additional_property_data(self)
    
    #TODO remove from code in the end
    def add_selected_items_2(self):  #Remove 2 if not needed 
        insertion_class = add_properties
        init = tableFunctions()
        table = self.tblvResults_Confirm
        selected_indexes = table.selectionModel().selectedRows()
        
        # Set to store data
        data = set()
        count = 0
        for index in selected_indexes:
            each_data = init.extract_property_data(index, table)
            if each_data:
                data.add(f'{each_data}')

            insertion_class.add_single_property_item(self,each_data)
            count =+ 1
            
        print("Kinnistud lisatud")

        #print(f"each data {each_data}")
        # Convert the set data to a comma-separated string
        #print(f"data before join {data}")
        #data = ', '.join(data)
        #ids = [id_string]
        #ids = list(data)       
        #print(f"dat a after join {data}")
        #return data
        

        

    def get_state_list(self):
        self.sw_HM.setCurrentIndex(3)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
        self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(2)
        try:
            layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        except IndexError:
            #print(f"Layer '{input_layer_name}' not found.")
            QMessageBox.warning(self, "Oi Oi Oi", f"Oih - midagi jäi puudu! \n Laetavate kinnistute kiht {input_layer_name} on puud. \n jätkamiseks lae algandmed")
            #print("No items selected")
            return
        hide_buttons = [self.pbDone_State, 
                        self.pbDoneCity,
                        self.pbConfirm_action,
                        self.pbSendItemstoMailabl,
                        self.pbCancel_streets_reset,
                        self.pbConfirm_streets_action]
        
        list_views = [self.listWidget_State, 
                        self.listWidget_City]
        
        checkboxes = [self.cbChooseAll_States,
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                            self.tblvResults_Confirm]


        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)
        

        viewItem_county = self.listWidget_county
        viewItem_state = self.listWidget_State
        
        # When calling functions in other classes, pass object names as strings
        
        item_county = viewItem_county.currentItem()
        item_state = viewItem_state.selectedItems()
        
        county_restriction = item_county.text() if item_county is not None else ""
        state_restrictions = "', '".join([item.text() for item in item_state]) if item_state else ""
        #print(f"Selected items state: {state_restrictions}")
        city_restrictions_before = ""
        
        #print(f"Restriction: {restriction}")
        item_count_before = graph_tools.count_items_in_layer(input_layer_name)
        sorted_values = graph_tools.create_item_list_with_where(viewItem_state, item_count_before, county_restriction, input_layer_name, county_nimi_field, state_nimi_field)
        list_functions.insert_values_to_listView_object(viewItem_state,sorted_values) 
        #viewItem_state.addItems(sorted_values)
        #viewItem_state.update()
        
        expression_before = graph_tools.universal_map_simplifier(
                            input_layer_name,
                            county_nimi_field, 
                            state_nimi_field,
                            city_nimi_field,
                            county_restriction, 
                            state_restrictions, 
                            city_restrictions_before
                            )
        
        layer.setSubsetString(expression_before)
        layer.triggerRepaint()
        layer.updateExtents()
        graph_tools.activateLayer_zoomTo(layer)
        item_count = graph_tools.count_items_in_layer(input_layer_name)
        self.lblCount.setText(f"{item_count}")
        self.pbDone_State.show()
        self.cbChooseAll_States.show()
        

    def get_city_list(self):
        self.sw_HM.setCurrentIndex(3)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
        self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(3)
        layer_name = load.load_SHP_inputLayer_name()
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]
        
        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()
        layer.blockSignals(False)
        
        hide_buttons = [ 
                        self.pbDoneCity,
                        self.pbConfirm_action,
                        self.pbSendItemstoMailabl,
                        self.pbCancel_streets_reset,
                        self.pbConfirm_streets_action]
        
        list_views = [ 
                        self.listWidget_City]
        
        checkboxes = [
                        self.cbChooseAll_Cities,
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        self.cbOnPropertiesTab_Include_streets]
        object_tables = [self.tblvResults_streets_Confirm,
                        self.tblvResults_Confirm]

        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)
        
        viewItem_county = self.listWidget_county
        viewItem_state = self.listWidget_State
        viewItem_city = self.listWidget_City
            
        # When calling functions in other classes, pass object names as strings
        
        item_county = viewItem_county.currentItem()
        item_state = viewItem_state.selectedItems()
        item_city = viewItem_city.selectedItems()

        county_restriction = item_county.text() if item_county is not None else ""
        state_restrictions_before = ""
        state_restrictions = "', '".join([item.text() for item in item_state]) if item_state else ""
        #print(f"Selected items state: {state_restrictions}")
        city_restrictions = "', '".join([item.text() for item in item_city]) if item_city else ""
        #print(f"Selected items city: {city_restrictions}")

        if item_county is None:
            #print("print")
            message = ("Vähemalt üks omavalitsus peab olema valitud.")
            QMessageBox.information(self, "Oi oi oi - mingi jama", message)
        else:
            
            expression_before = graph_tools.universal_map_simplifier(
                                input_layer_name,
                                county_nimi_field, 
                                state_nimi_field,
                                city_nimi_field,
                                county_restriction, 
                                state_restrictions_before, 
                                city_restrictions
                                )
            
            layer.setSubsetString(expression_before)
            layer.triggerRepaint()
            layer.updateExtents()
            #print(f"Expression before {expression_before}")
            # Check if any items are selected
            if item_state:
                # Retrieve and print the text of selected items
                items_name_state = [item.text() for item in item_state]
                #print(f"Selected items: {items_name_state}")
            else:
                QMessageBox.warning(self, "Oih - midagi jäi puudu!", "Jätkamiseks vali mõni linn/või küla!")
                #print("No items selected")
                pass

            item_count_before = graph_tools.count_items_in_layer(input_layer_name)    
            city_list = graph_tools.create_item_list_with_MultyWhere(item_count_before, items_name_state, input_layer_name, state_nimi_field, city_nimi_field)
            list_functions.insert_values_to_listView_object(viewItem_city, city_list)
            #viewItem_city.update()

            expression = graph_tools.universal_map_simplifier(
                                input_layer_name,
                                county_nimi_field, 
                                state_nimi_field,
                                city_nimi_field,
                                county_restriction, 
                                state_restrictions, 
                                city_restrictions
                                )
            
            layer.setSubsetString(expression)
            layer.triggerRepaint()
            layer.updateExtents()
            graph_tools.activateLayer_zoomTo(layer)
            item_count = graph_tools.count_items_in_layer(input_layer_name)
            self.lblCount.setText(f"{item_count}")
            self.pbDoneCity.show()
            self.cbChooseAll_Cities.show()

#Loads only properties that are not "streets or roads"
    def prepare_properties_list_and_Add_to_table_updated_with_selecting_items(self):
        #TODO setup help lists add help class and call function for each buttons
        self.sw_HM.setCurrentIndex(3)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
        self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(3)
        
        #Start real function
        tab_widget = self.tabWidget_Propertie_list  
        TabHandler.tabViewByState(tab_widget,state=True)
        layer_name = load.load_SHP_inputLayer_name()
        #print(f"shp_input_layer_name {layer_name}")
        layer = QgsProject.instance().mapLayersByName(layer_name)[0]
        #TODO rethink signal blocking!
        layer.blockSignals(True)
        # Deselect all selected items on the map
        layer.removeSelection()
        layer.blockSignals(False)

        #Create lists to store itemas
        hide_buttons = []
        list_views = []
        
        checkboxes = [
                        self.cbChooseAllAdd_properties, 
                        self.cbChooseAllAdd__street_properties,
                        ]
        object_tables = [self.tblvResults_streets_Confirm,
                        self.tblvResults_Confirm]
        #clear to proper stage = hide and clear tables, buttons and checkboxes
        list_functions.unload_and_hide_connectedItems(list_views, 
                                            object_tables,
                                            hide_buttons,
                                            checkboxes)

        self.cbChooseAllAdd_properties.blockSignals(True)
        self.cbChooseAllAdd__street_properties.blockSignals(True)

        viewItem_county = self.listWidget_county
        viewItem_state = self.listWidget_State
        viewItem_city = self.listWidget_City
        # When calling functions in other classes, pass object names as strings
        item_county = viewItem_county.currentItem()
        item_state = viewItem_state.selectedItems()
        item_city = viewItem_city.selectedItems()

        county_restriction = item_county.text() if item_county is not None else ""
        state_restrictions = "', '".join([item.text() for item in item_state]) if item_state else ""
        #print(f"Selected items state: {state_restrictions}")
        city_restrictions = "', '".join([item.text() for item in item_city]) if item_city else ""
        #print(f"Selected items city: {city_restrictions}")
        self.tabWidget_Propertie_list.setCurrentIndex(0)
        self.tabWidget_Propertie_list.show()
        self.cbChooseAllAdd_properties.show()
        self.cbOnPropertiesTab_Include_streets.show()
        self.cbChooseAllAdd__street_properties.show()
        
        #Clean code in universal map simplifier because it creates only expression 
        expression = graph_tools.universal_map_simplifier(
                            input_layer_name,
                            county_nimi_field, 
                            state_nimi_field,
                            city_nimi_field,
                            county_restriction, 
                            state_restrictions, 
                            city_restrictions
                            )
        # Disable signals for the layer        
        
        
        layer.setSubsetString(expression)
        layer.triggerRepaint()
        layer.updateExtents()
        layer.blockSignals(True)
        layer.selectAll()        
        model_without_transport, model_with_transport, total = table_functions.generate_table_from_selected_map_items_with_roads(layer_name)
        
        # Block the signal temporarily

        table_view_1 = self.tblvResults_streets_Confirm
        table_view_2 = self.tblvResults_Confirm
        self.lblCount.setText(str(total))
        
        table_view_1.setModel(model_with_transport)
        table_view_2.setModel(model_without_transport)
        #TODO if function sets to work 
        #TableViewadjuster.QTableView_look(table_view_1)
        #TableViewadjuster.QTableView_look(table_view_2)
        custom_row_height = 20  # Adjust this value as needed
        for row in range(model_with_transport.rowCount()):
            table_view_1.setRowHeight(row, custom_row_height) 
            table_view_2.setRowHeight(row, custom_row_height) 
        
        table_view_1.setSortingEnabled(True)
        table_view_2.setSortingEnabled(True)
        
        # Hide the vertical header (row numbers)
        table_view_1.verticalHeader().setVisible(False)
        table_view_2.verticalHeader().setVisible(False)
        
        # Optional: Hide grid lines
        table_view_1.setShowGrid(False)
        table_view_2.setShowGrid(False)
        
        # Automatically resize columns to fit content
        table_view_1.resizeColumnsToContents()
        table_view_2.resizeColumnsToContents()
        
        # Block editing for all cells
        table_view_1.setEditTriggers(QTableView.NoEditTriggers)
        table_view_2.setEditTriggers(QTableView.NoEditTriggers)
        
        # Unblock the signal after setting the models
        self.cbChooseAllAdd_properties.blockSignals(False)
        self.cbChooseAllAdd__street_properties.blockSignals(False)
    
        # MArk checkboxes
        self.cbChooseAllAdd_properties.setChecked(True)
        self.cbOnPropertiesTab_Include_streets.setChecked(True)

        # Disable signals for the layer
        layer.blockSignals(False)
        
        self.pbConfirm_action.show()

#Can be written off
    def prepare_properties_list_and_Add_to_table(self):
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        self.tabWidget_Propertie_list.show()
        
        object_county = self.listWidget_county
        object_state = self.listWidget_State
        object_city = self.listWidget_City
        
        item_county = object_county.currentItem()
        restriction_county = item_county.text()
        #print(f"Restriction 1 {restriction_county}")
        
        #object_state.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_states = object_state.selectedItems()
        restriction_state = [item.text() for item in selected_states]
        #print(f"Restriction 2 {restriction_state}")
        
        #object_city.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_cities = object_city.selectedItems()
        restriction_city = [item.text() for item in selected_cities]
        #print(f"Restriction 3 {restriction_city}")
        
        #expression = " {} IN ('{}') AND {} IN ('{}') AND {} IN ('{}')" .format(county_nimi_field, restriction_county, state_nimi_field, "', '".join(restriction_state),city_nimi_field,"', '".join(restriction_city))
        expression = " {} IN ('{}') AND {} IN ('{}') AND {} IN ('{}') AND SIHT1 NOT IN ('Transpordimaa')" .format(county_nimi_field, restriction_county, state_nimi_field, "', '".join(restriction_state),city_nimi_field,"', '".join(restriction_city))
        
        layer.setSubsetString(expression)
        layer.triggerRepaint()
        
        self.prepare_properties_list()
        self.prepare_streets_list()
        

        
    def prepare_properties_list(self):
        table_view = self.tblvResults_Confirm

        object_county = self.listWidget_county
        object_state = self.listWidget_State
        object_city = self.listWidget_City
        
        item_county = object_county.currentItem()
        restriction_county = item_county.text()
        #print(f"Restriction 1 {restriction_county}")
        
        object_state.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_states = object_state.selectedItems()
        restriction_state = [item.text() for item in selected_states]
        #print(f"Restriction 2 {restriction_state}")
        
        object_city.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_cities = object_city.selectedItems()
        restriction_city = [item.text() for item in selected_cities]
        #print(f"Restriction 3 {restriction_city}")
        
        expression = " {} IN ('{}') AND {} IN ('{}') AND {} IN ('{}')" .format(county_nimi_field, restriction_county, state_nimi_field, "', '".join(restriction_state),city_nimi_field,"', '".join(restriction_city))
        #print(f"Expression: {expression}")
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        layer.setSubsetString(expression)

        
        #layer.triggerRepaint()
        #layer.updateExtents()
        #graph_tools.zoom_to_layer_extent(layer)
        item_count = graph_tools.count_items_in_layer(input_layer_name)
        self.lblCount.setText(f"{item_count}")
        table_functions.generate_table_view_headers(table_view,input_layer_name, item_count)
        
        layer.triggerRepaint()
        layer.updateExtents()
        graph_tools.activateLayer_zoomTo(layer)
        self.lblCount.setText(f"{item_count}")
        
        self.pbSendItemstoMailabl.show()        
        self.cbChooseAllAdd_properties.show()
        
    
        
    def prepare_streets_list(self):
        object_county = self.listWidget_county
        object_state = self.listWidget_State
        object_city = self.listWidget_City
        table_view = self.tblvResults_streets_Confirm
        
        item_county = object_county.currentItem()
        restriction_county = item_county.text()
        #print(f"Restriction 1 {restriction_county}")
        
        object_state.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_states = object_state.selectedItems()
        restriction_state = [item.text() for item in selected_states]
        #print(f"Restriction 2 {restriction_state}")
        
        object_city.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_cities = object_city.selectedItems()
        restriction_city = [item.text() for item in selected_cities]
        #print(f"Restriction 3 {restriction_city}")
        expression = " {} IN ('{}') AND {} IN ('{}') AND {} IN ('{}') AND SIHT1 IN ('Transpordimaa')" .format(county_nimi_field, restriction_county, state_nimi_field, "', '".join(restriction_state),city_nimi_field,"', '".join(restriction_city))
        #print(f"Expression: {expression}")
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        layer.setSubsetString(expression)
        #layer.triggerRepaint()
        #layer.updateExtents()
        #graph_tools.zoom_to_layer_extent(layer)
        item_count = graph_tools.count_items_in_layer(input_layer_name)
        table_functions.generate_table_view_headers(table_view,input_layer_name, item_count)


    def prepare_streets_list_from_selected_items(self):

        table_view = self.tblvResults_streets_Confirm

        table_functions.generate_table_from_selected_map_items(table_view,input_layer_name)


#Remove statements
        
    def get_state_list_2(self):
        object_county = self.listWidget_county_2
        object_state = self.listWidget_State_2
        item = object_county.currentItem()
        restriction = item.text()
        #print(f"Restriction: {restriction}")
        item_count_before = graph_tools.count_items_in_layer(input_layer_name)
        state_list = graph_tools.create_item_list_with_where(item_count_before, restriction, input_layer_name, county_nimi_field, state_nimi_field)
        list_functions.insert_values_to_listView_object(object_state, state_list)
        object_state.update()
        
        expression = "{} IN ('{}')".format(county_nimi_field, restriction)
        #print(f"Expression: {expression}")
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        layer.setSubsetString(expression)
        layer.triggerRepaint()
        layer.updateExtents()
        graph_tools.activateLayer_zoomTo(layer)
        item_count = graph_tools.count_items_in_layer(input_layer_name)
        self.lblCount_2.setText(f"{item_count}")
        
        
    def get_city_list_2(self):
        object_county = self.listWidget_county_2
        item_county = object_county.currentItem()
        restriction_county = item_county.text()
        
        object_state = self.listWidget_State_2
        object_city = self.listWidget_City_2
        object_city.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys

        selected_items = object_state.selectedItems()
        # Check if any items are selected
        if selected_items:
            # Retrieve and print the text of selected items
            items_name_city = [item.text() for item in selected_items]
            print(f"Selected items: {items_name_city}")
        else:
            print("No items selected")
    
        city_list = graph_tools.create_item_list_with_MultyWhere(items_name_city, input_layer_name, state_nimi_field, city_nimi_field)
        list_functions.insert_values_to_listView_object(object_city, city_list)
        object_city.update()

        expression = " {} IN ('{}') AND {} IN ('{}')".format(county_nimi_field, restriction_county, state_nimi_field, "', '".join(items_name_city))
        print(f"Expression: {expression}")
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        layer.setSubsetString(expression)
        layer.triggerRepaint()
        layer.updateExtents()
        graph_tools.activateLayer_zoomTo(layer)
        item_count = graph_tools.count_items_in_layer(input_layer_name)
        self.lblCount_2.setText(f"{item_count}")
        
    def prepare_properties_list_2(self):
        object_county = self.listWidget_county_2
        object_state = self.listWidget_State_2
        object_city = self.listWidget_City_2
        
        item_county = object_county.currentItem()
        restriction_county = item_county.text()
        #print(f"Restriction 1 {restriction_county}")
        
        object_state.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_states = object_state.selectedItems()
        restriction_state = [item.text() for item in selected_states]
        #print(f"Restriction 2 {restriction_state}")
        
        object_city.setSelectionMode(QListView.ExtendedSelection)  # Allows selecting multiple items with Ctrl or Shift keys
        selected_cities = object_city.selectedItems()
        restriction_city = [item.text() for item in selected_cities]
        #print(f"Restriction 3 {restriction_city}")
        
        expression = " {} IN ('{}') AND {} IN ('{}') AND {} IN ('{}')" .format(county_nimi_field, restriction_county, state_nimi_field, "', '".join(restriction_state),city_nimi_field,"', '".join(restriction_city))

        #print(f"Expression: {expression}")
        layer = QgsProject.instance().mapLayersByName(input_layer_name)[0]
        layer.setSubsetString(expression)
        layer.triggerRepaint()
        layer.updateExtents()
        graph_tools.activateLayer_zoomTo(layer)
        item_count = graph_tools.count_items_in_layer(input_layer_name)
        self.lblCount_2.setText(f"{item_count}")
        table_functions.generate_table_view_headers(self.tblvResults_Confirm_2,input_layer_name)

    #def lwCounty_setuphelp (self):
    #    self.sw_HM.setCurrentIndex(3)
    #    self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
    #    self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(1)
    
    def pb_Cadasters_change_help(self):
        self.swWorkSpace.setCurrentIndex(1)
        self.sw_HM.setCurrentIndex(3)
        self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(2)
        self.swCadastral_sub_processes.setCurrentIndex(4)
        LayerChecker.SHP_Layer_Checker(self, input_layer_name)
        #self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(0)
        

    def on_load(self):    

        self.swWorkSpace.setCurrentIndex(5)  
        frames = {
            "frame1": self.leftMenuContainer,
            "frame2": self.rightMenuContainer,
            "frame3": self.UC_Main_Frame,
            "frame4": self.sw_HM,
            "frame5": self.Intro_Help,
            "frame6": self.HomePageName,
            "frame7": self.Genrealprogresbar,
            "frame8": self.frProjects_Tools,
            "frame9": self.SettingsPageMainFrame,
            "frame10": self.frSync_Cadastrals_Main,
            "frame11": self.frSync_Overview_Main,
            "frame12": self.frSync_Tools

            }

        frame_handler = FrameHandler(frames)

        # To hide frame1 and frame2 in a single line
        frame_handler.hide_frame("frame1")
        frame_handler.hide_frame("frame2")
        frame_handler.hide_frame("frame4")
        frame_handler.hide_frame("frame5")
        frame_handler.hide_frame("frame6")
        frame_handler.hide_frame("frame7")
        frame_handler.hide_frame("frame8")
        frame_handler.hide_frame("frame9")
        frame_handler.hide_frame("frame10")
        frame_handler.hide_frame("frame11")
        frame_handler.hide_frame("frame12")
        
    #creditentials handling
    def remove_UC_data(self):
        clear_UC_data()

    def save_user_data(self):
        save_results = save_user_name(self)
        access_token_results = get_access_token(self)
        #print(access_token_results)

        frames = {
            "frame1": self.leftMenuContainer,
            "frame2": self.rightMenuContainer,
            "frame3": self.UC_Main_Frame,
            "frame4": self.sw_HM,
            "frame5": self.Intro_Help,
            "frame6": self.HomePageName,
            "frame7": self.frProjects_Tools,
            "frame8": self.SettingsPageMainFrame,
            "frame9": self.frSync_Cadastrals_Main,
            "frame10": self.frSync_Overview_Main,
            "frame11": self.frSync_Tools
            }

        frame_handler = FrameHandler(frames)

        if access_token_results == "success":
            
            # To hide frame1 and frame2 in a single line
            frame_handler.show_frame("frame1")
            frame_handler.show_frame("frame2")
            frame_handler.hide_frame("frame3")
            frame_handler.show_frame("frame4")
            frame_handler.show_frame("frame5")
            frame_handler.show_frame("frame7")
            frame_handler.show_frame("frame8")
            frame_handler.show_frame("frame9")
            frame_handler.show_frame("frame10")
            frame_handler.show_frame("frame11")
            #frame_handler.show_frame("frame6")
            # Access token is available, proceed with saving user data
            # ... your code to save user data ...
            #print(access_token_results)
            self.resize(1150, 700)
        elif access_token_results == "error on access token":
            # Handle the error condition
            # ... your code to handle the error
            print(access_token_results)

        
    def print_UC_data(self):
        print_result(self)    





    def layer_setup(self):
        #print("started 'layer_setup'")
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        Setup_CadastralsLayers.load_layer_settings_widget(self, lblcurrent_main_layer_label,lblnewCadastrals_input_layer_label,lblSHPNewItems)
        
    '''
    def load_project_settings_widget(self):
        #global properties_settings_widget 
        filepaths = Filepaths()
        qgis_items_instance = QGIS_items()
        widget_name = filepaths.Setup_ConfigUI
        widget = loadUi(filepaths.Config_ProjectSettings_Widget(widget_name))
        
        
        cmb_layers  = widget.findChild(QtWidgets.QComboBox, "cmbUserLayers")
        #cmb_layers  = widget.cmbUserLayers
        #print("ComboBox:", cmb_layers)

        
        if cmb_layers:
            qgis_items_instance.clear_and_populate_combo_box(cmb_layers)    
        
        else:
            print("Input Layer combobox not found within the loaded widget.")
        widget.exec_()
    '''     

    def set_layer_settings_labels(self):
        #load = SettingsDataSaveAndLoad()
        lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
        lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
        lblSHPNewItems = self.lblSHPNewItems
        lblLayerProjects_Properties = self.lblLayerProjects_Properties
        load.startup_label_loader(lblcurrent_main_layer_label,lblnewCadastrals_input_layer_label,lblSHPNewItems, lblLayerProjects_Properties)        

    def load_cadastrals(self):
        self.sw_HM.setCurrentIndex(7)
        self.sw_HM_Andmete_laadimine.setCurrentIndex(1)
        self.swWorkSpace.setCurrentIndex(1)
        self.swCadastral_sub_processes.setCurrentIndex(4)
        label = self.lblSHPNewItems
        SHPLayerLoader.load_shp_layer(label)
        #shp_input = load.load_SHP_inputLayer_name()        
        color_handler.changeButtonColor(self, self.pbCadasters, self.pbExpand, self.pbRefresh, self. pbSyncMailabl, self.pbAvaMaaameti_veebikas, self.pbAdd_SHP_To_Project, input_layer_name, self.Start_update)                                


    def show_projects_on_map_with_cadastral_connection(self):
        #def show_connected_cadasters(values, layer_type):
        layer_type = "active"
        cadasters = CadasterSelector.projects_return_cadasters(self,table = self.tblProjects) 
        properties_selectors.show_connected_cadasters(self, layer_type=layer_type, values=cadasters)
        cadasters.clear()


    def connect_properties_with_projects(self):
        global projects_widget
        table = self.tblMailabl_projects
        model = table.model()
        selection_model = table.selectionModel()

        if selection_model.hasSelection():
            selected_index = selection_model.currentIndex()
            projects_name = model.item(selected_index.row(), 2)
            if projects_name is not None:
                projects_name_text = projects_name.text()
            
            projects_number = model.item(selected_index.row(), 1)
            projects_number_text = projects_number.text()
            
            Mailabl_ID = model.item(selected_index.row(), 0)
            Mailabl_ID_text = Mailabl_ID.text()
            #print(f"Mailabl ID: {Mailabl_ID_text}")
            
            layer_name = load.load_target_cadastral_name()
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            iface.setActiveLayer(layer)
            #layer.removeSelection()
            
            widget = ToolsProject.projects_toolWidget(self, projects_name_text, projects_number_text)
            projects_widget = widget
            clear_table = widget.pbClear_list
            table_view = widget.tvProperties_AddTo_Projects
            
            flag = flags.active_properties_layer_flag 
            flag = True        
            flags.active_properties_layer_flag = flag
            
        
            
            PropertieLayerFunctions.generate_table_from_selected_map_items_simple(self,table_view, layer_name)
            map_selectors.activate_layer_and_use_selectTool_on_first_load(self, widget)
            clear_table.clicked.connect(lambda: shp_tools.clear_table_and_layer(table_view, layer_name))

            widget.show()
            
            widget.accepted.connect(lambda: ProjectsProperties.update_projects_properties(self, Mailabl_ID_text, widget, projects_name_text))
            widget.rejected.connect(lambda: ProjectsProperties.on_cancel_button_clicked(widget))
            
        else:
            QMessageBox.information(self, "Jama", "Pead valima ühe projekti")

        
    def generate_virtual_mapLayer_synced_with_Mailabl(self):
        # Create an instance of YourClas
        lblFor_Sync_GreatLayerName = self.leText_For_Sync_GreateLayerName
        frSync_Cadastrals_Main = self.frSync_Cadastrals_Main
        county_list_widget = self.lwSync_County_Names
        state_list_widget = self.lwSync_State_Names
        city_list_widget = self.lwSync_City_Names
        pBar_County_list = self.pBar_Sync_County
        pBar_State_list = self.pBar_State_list 
        pBar_City_list = self.pBar_City_list
        pBar_City_items = self.pBar_CityItems
        lblSync_General = self.lblSync_General
        lblSync_General_aditional = self.lblSync_General_aditional
        lblFor_pBar_County_list = self.lblFor_pBar_Sync_County
        lblFor_pBar_State_list = self.lblFor_pBar_State_list 
        lblFor_pBar_City_list = self.lblFor_pBar_City_list
        lblFor_pBar_City_items = self.lblFor_pBar_CityItems
        Sync_Cadastrals = self.Sync_Cadastrals
        frSync_Overview_Main = self.frSync_Overview_Main
        frSync_Tools = self.frSync_Tools
        a = self.a
        b= self.b
        c = self.c
        d = self.d
        
        self.your_instance = PropertiesBaseMap(lblFor_Sync_GreatLayerName, frSync_Cadastrals_Main, county_list_widget,
                state_list_widget, city_list_widget, pBar_County_list, pBar_State_list,
                pBar_City_list, pBar_City_items, lblSync_General, lblSync_General_aditional,
                lblFor_pBar_County_list, lblFor_pBar_State_list, lblFor_pBar_City_list,
                lblFor_pBar_City_items, Sync_Cadastrals, frSync_Overview_Main, frSync_Tools, a, b, c, d)
        # Connect the button click signal to the prepare_items_for_base_map method
        self.your_instance.prepare_items_for_base_map()




#TODO -  move to projeckts list!        
    def update_tblMailabl_projects(self):
        button = self.pbRefresh_tblMailabl_projects
        button.blockSingnals = True
        table = self.tblMailabl_projects
        Projects.load_Mailabl_projects_list(self, table)
        button.blockSingnals = False
        
        
    def Delete_reset_stage(self):
        Delete_Main_Process.Delete_process_view_on_countyListView_click(self)
        
    def Delete_reset_to_stage_state(self):
        Delete_Main_Process.Delete_process_view_after_county(self)
    
    def delete_process_after_county(self):
        lwDel_County_Names = self.lwDelete_County_Names
        lwDel_State_names = self.lwDel_State_Names
        lwDel_City_Names = self.lwDelete_Cities_Names

        check_items = lwDel_County_Names.selectedItems()
        if not check_items:
            Delete_Main_Process.Delete_process_view_after_unsuccessful_county(self)
            # No item selected, perform your desired action here
            QMessageBox.warning(self, "Jama", "Pead valima vähemalt ühe maakonna")
            
        else:
            # Item selected, continue with your process        
            lbl = self.lblDel_Amount
            Delete_Main_Process.Delete_process_view_after_county(self)
            
            button_to_activate = self.pbDel_County
            activ_cadastral_layer = load.load_target_cadastral_name()
            f_delete.DeleteProcess_get_state_list(button_to_activate, activ_cadastral_layer, 
                                                state_nimi_field, 
                                                county_nimi_field,
                                                city_nimi_field,
                                                lwDel_County_Names,
                                                lwDel_State_names,
                                                lwDel_City_Names,
                                                lbl
                                                )
            
            #planned help menu changes!
            self.sw_HM.setCurrentIndex(3)
            self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
            self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(2)
        
    def delete_process_after_state(self):
        lwDel_County_Names = self.lwDelete_County_Names
        lwDel_State_names = self.lwDel_State_Names
        lwDel_City_Names = self.lwDelete_Cities_Names
        
        check_items = lwDel_State_names.selectedItems()
        if not check_items:
            Delete_Main_Process.Delete_process_view_after_unsuccessful_state(self)
            # No item selected, perform your desired action here
            QMessageBox.warning(self, "Jama", "Pead valima vähemalt ühe omavalitsuse valima")
        else:
            Delete_Main_Process.Delete_process_view_after_state(self)

            lbl = self.lblDel_Amount        
            button = self.pbDel_State
            activ_cadastral_layer = load.load_target_cadastral_name()
            f_delete.DeleteProcess_get_city_list(button, activ_cadastral_layer, 
                                                state_nimi_field, 
                                                county_nimi_field,
                                                city_nimi_field,
                                                lwDel_County_Names,
                                                lwDel_State_names,
                                                lwDel_City_Names,
                                                lbl
                                                )
            
            #planned help menu changes!
            self.sw_HM.setCurrentIndex(3)
            self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
            self.sw_HM_Toimingud_kinnistutega_Laiendamine.setCurrentIndex(2)
            
    #@staticmethod
    def delete_process_after_city(self):
        lwDel_County_Names = self.lwDelete_County_Names
        lwDel_State_names = self.lwDel_State_Names
        lwDel_City_Names = self.lwDelete_Cities_Names
        lbl = self.lblDel_Amount        
        button = self.pbDel_City
        tab_widget = self.tabW_Delete_list
        TabHandler.tabViewByState(tab_widget,state=True)
        button.blockSignals(True)
        
        check_items = lwDel_State_names.selectedItems()
        if not check_items:
            Delete_Main_Process.Delete_process_view_after_unsuccessful_city(self)
            # No item selected, perform your desired action here
            QMessageBox.warning(self, "Jama", "Pead valima vähemalt ühe omavalitsuse valima")
        else:
            Delete_Main_Process.Delete_process_view_after_city(self)
            lbl = self.lblDel_Amount        
            button = self.pbDel_City
            
            layer_name = load.load_target_cadastral_name()
            #print(f"shp_input_layer_name {layer_name}")
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            #TODO rethink signal blocking!
            layer.blockSignals(True)
            # Deselect all selected items on the map
            layer.removeSelection()
            layer.blockSignals(False)
            
            County_Names =   lwDel_County_Names.currentItem()
            State_names = lwDel_State_names.selectedItems()
            City_Names = lwDel_City_Names.selectedItems()
            
            county_restriction = County_Names.text() if County_Names is not None else ""
            state_restrictions = "', '".join([item.text() for item in State_names]) if State_names else ""
            #print(f"Selected items state: {state_restrictions}")
            city_restrictions = "', '".join([item.text() for item in City_Names]) if City_Names else ""
            #print(f"Selected items city: {city_restrictions}")
            self.tabW_Delete_list.setCurrentIndex(0)  
            self.tabW_Delete_list.show()
            Delete_Main_Process.Delete_process_view_after_city(self)
            #Clean code in universal map simplifier because it creates only expression 
            expression = graph_tools.universal_map_simplifier(
                                layer_name,
                                county_nimi_field, 
                                state_nimi_field,
                                city_nimi_field,
                                county_restriction, 
                                state_restrictions, 
                                city_restrictions
                                )
            # Disable signals for the layer        
            layer.setSubsetString(expression)
            layer.triggerRepaint()
            layer.updateExtents()
            layer.blockSignals(True)
            layer.selectAll()    
            graph_tools.activateLayer_zoomTo(layer)
            model_without_transport, model_with_transport, total = table_functions.generate_table_from_selected_map_items_with_roads(layer_name)
            delete_tables.insert_data_to_tables(self, DelModel_streets=model_with_transport, DelModel_properties=model_without_transport, total=total, lbl=lbl)
            layer.blockSignals(False)
            
        delete_checkboxes.checkboxes_on_after_city(self)
        button.blockSignals(False)

    def DeleteProcess_check_validity_in_Mylabl (self):
        activ_cadastral_layer = load.load_target_cadastral_name()
        #Delete_finalProcess.delete_selected_items_from_mylabl(self, tbl_Delete_properties, tbl_Delete_streets)
        DeleteActions.delete_selected_items_from_mylabl(self)
        
    #@staticmethod
    def toggle_settings_main_view(self):
            input_layer_name = load.load_SHP_inputLayer_name()
            color.changeButtonColor(self.pbCadasters, self.pbExpand, self.pbRefresh, self. pbSyncMailabl, self.pbAvaMaaameti_veebikas, self.pbAdd_SHP_To_Project, input_layer_name, self.Start_update)
            self.swWorkSpace.setCurrentIndex(4)
            self.sw_HM.setCurrentIndex(4)
            self.sw_HM_Toimingud_kinnistutega.setCurrentIndex(0)
            widget = self.pbSettings_SliderFrame   
            
            lblcurrent_main_layer_label = self.lblcurrent_main_layer_label
            lblnewCadastrals_input_layer_label = self.lblnewCadastrals_input_layer_label
            lblSHPNewItems = self.lblSHPNewItems
            lblLayerProjects_Properties = self.lblLayerProjects_Properties
            SettingsDataSaveAndLoad.startup_label_loader(self, lblcurrent_main_layer_label,lblnewCadastrals_input_layer_label,lblSHPNewItems, lblLayerProjects_Properties)

            if flags.Flag_settings_button:
                print("toggle if")
                WidgetAnimator.toggle_Frame_height_for_settings(self, widget)
                #widget.setMaximumHeight(16777215)
                #QTimer.singleShot(600, lambda: WidgetAnimator.toggle_Frame_height_for_settings(self, widget))
            else:
                print("toggle else")
                secondLevelButtonsHandler.toggle_Frame_height_DataLoading(self)
                secondLevelButtonsHandler.toggle_Frame_height_Cadaster_functions(self)
                #widget.setMaximumHeight(0)
            flags.Flag_settings_button = not flags.Flag_settings_button
            print(f"Flags: {flags.Flag_settings_button}")


################################################################################################################
